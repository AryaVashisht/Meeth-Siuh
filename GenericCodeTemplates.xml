<codeTemplateLibrary version="3.5.0">
  <id>3f3cdf24-eb5c-4fee-aad6-8b87ba5fa7db</id>
  <name>GenericCodeTemplates</name>
  <revision>14</revision>
  <lastModified>
    <time>1600852824247</time>
    <timezone>America/New_York</timezone>
  </lastModified>
  <description></description>
  <includeNewChannels>false</includeNewChannels>
  <enabledChannelIds>
        <string>8ffc3435-69a9-4e3c-a7b3-d92bfe08016a</string>
        <string>b0583467-c7c3-47c6-8b17-8aa320566e3f</string>
        <string>5327db88-2288-4b83-ae93-4381b82e73e0</string>
        <string>bc5479c7-2c1e-44f5-ac09-7167da64c097</string>
        <string>b7f713c7-9538-4fe5-8217-622ba55ac61d</string>
        <string>4dad803b-8ae7-4ccd-8a63-f5b7ad900c34</string>
        <string>8dcf6511-0d95-460a-9050-047679091da3</string>
        <string>22a6ce40-6759-402c-8659-bca069ddfe01</string>
        <string>a5b7b331-5a27-4fab-9940-5de24ddf4d7a</string>
        <string>e84827ea-74b1-4f4c-a3be-96a9346be3bb</string>
        <string>72877cb0-e059-4284-a0a9-daad839255e6</string>
        <string>b0120ac5-373f-4786-9fed-be8e50f93af0</string>
        <string>ba9df7b5-0270-47f0-83f3-2bbb1e11f5f3</string>
        <string>063d6304-cd71-45d6-92a5-d9efbdb2fdfa</string>
    </enabledChannelIds>
   <disabledChannelIds>
        <string>9f0baca7-6d5f-4acb-9d22-4693751ac72b</string>
        <string>b81372e9-e063-4dbe-a6bb-8955abcbd5df</string>
        <string>caf78903-6104-4d43-be30-8d34e26121ec</string>
  </disabledChannelIds>
  <codeTemplates>
    <codeTemplate version="3.5.0">
      <id>9fe5391f-535c-43d8-a9a7-3b0e34e7c4e7</id>
      <name>apiRequest</name>
      <revision>4</revision>
      <lastModified>
        <time>1597478534520</time>
        <timezone>America/New_York</timezone>
      </lastModified>
      <contextSet>
        <delegate>
          <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
          <contextType>DESTINATION_DISPATCHER</contextType>
          <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
          <contextType>SOURCE_RECEIVER</contextType>
          <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
        </delegate>
      </contextSet>
      <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
        <type>FUNCTION</type>
        <code>/**
                                Modify the description here. Modify the function name and parameters as needed. One function per
                                template is recommended; create a new code template for each new function.

                                @param {String} arg1 - arg1 description
                                @return {String} return description
                                Send method as - POST ,PUT , DELETE , GET
                                Send Request Params as second Parameter
                                Send apiattr  token,apiInfo url in map
                                */
                                importPackage(Packages.org.apache.http.client);
                                importPackage(Packages.org.apache.http.client.methods);
                                importPackage(Packages.org.apache.http.impl.client);
                                importPackage(Packages.org.apache.http.message);
                                importPackage(Packages.org.apache.http.client.entity);
                                importPackage(Packages.org.apache.http.entity);
                                importPackage(Packages.org.apache.http.util);
                                importPackage(Packages.org.apache.http.ssl);
                                importPackage(Packages.org.apache.http.conn);
                                importPackage(Packages.org.apache.http.conn.ssl);
                                importPackage(Packages.org.apache.http.client.config);

                                function apiRequest(method,messageBody,apiAttributes){
                                var result={}
                                logger.info(&quot;Inside apiRequest | method : &quot;+method+&quot; , messageBody : &quot;+messageBody+&quot;, apiAttributes : &quot;+apiAttributes)
                                if(method==&apos;GET&apos;){
                                return result= getRequest(messageBody,apiAttributes)
                                }


                                if(method==&apos;POST&apos;){
                                return result = postRequest(messageBody,apiAttributes)
                                }

                                if(method==&apos;PUT&apos;){
                                return result = putRequest(messageBody,apiAttributes)
                                }

                                if(method==&apos;DELETE&apos;){
                                return result=deleteRequest(messageBody,apiAttributes)
                                }
                                }


                                function getRequest(requestParam, apiAttributes) {
                                logger.info(&quot;Inside Get Method with requestParams  &quot; + requestParam + &quot;API attributes&quot; + apiAttributes)
                                var httpclient = new DefaultHttpClient();

                                // Building the request

                                if (apiAttributes.get(&apos;url&apos;)) {
                                logger.info(&quot;Making Request to Url ==&quot; + apiAttributes.get(&apos;url&apos;))
                                var httpGet = new HttpGet(apiAttributes.get(&apos;url&apos;));
                                // Specify Headers which you want to send
                                httpGet.addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;);

                                apiAttributes.get(&apos;token&apos;) ? httpGet.addHeader(&quot;x-auth-token&quot;, apiAttributes.get(&apos;token&apos;)) : &quot;&quot;
                                apiAttributes.get(&apos;apiInfo&apos;) ? httpGet.addHeader(&quot;api-info&quot;, apiAttributes.get(&apos;apiInfo&apos;)) : &quot;&quot;

                                //httpGet.setEntity(new StringEntity(JSON.stringify(requestParam)))

                                var statusCode, entity, responseString, resp
                                try {
                                logger.info(&quot;Going to execute api request &quot;+requestParam)
                                resp = httpclient.execute(httpGet);
                                statusCode = resp.getStatusLine().getStatusCode();
                                entity = resp.getEntity();
                                responseString = EntityUtils.toString(entity, &quot;UTF-8&quot;);

                                if (statusCode == 200 || statusCode == 201) {
                                logger.info(&quot;API Executed succesfully with Status Code ===== &quot; + statusCode)
                                }
                                return responseString;

                                } catch (err) {
                                logger.error(&quot;Error Occured in GET Method &quot;  +  err);

                                }finally {
                                resp.close();
                                }

                                } else {
                                logger.error(&quot;[API Request Get] : Api Url is not defined in Request Map&quot;)
                                }


                                }

                                function putRequest(requestParam, apiAttributes) {
                                logger.info(&quot;Inside PUT Method with requestParams  &quot; + requestParam + &quot;API attributes&quot; + apiAttributes)
                                var httpclient = new DefaultHttpClient();
                                if (apiAttributes.get(&apos;url&apos;)) {
                                logger.info(&quot;Making Request to Url ==&quot; + apiAttributes.get(&apos;url&apos;))
                                var httpPut = new HttpPut(apiAttributes.get(&apos;url&apos;));
                                // Specify Headers which you want to send
                                httpPut.addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;);

                                apiAttributes.get(&apos;token&apos;) ? httpPut.addHeader(&quot;x-auth-token&quot;, apiAttributes.get(&apos;token&apos;)) : &quot;&quot;
                                apiAttributes.get(&apos;apiInfo&apos;) ? httpPut.addHeader(&quot;api-info&quot;, apiAttributes.get(&apos;apiInfo&apos;)) : &quot;&quot;

                                httpPut.setEntity(new StringEntity(JSON.stringify(requestParam)))

                                var statusCode, entity, responseString, resp
                                try {
                                logger.info(&quot;Going to execute api request &quot;+JSON.stringify(requestParam))
                                resp = httpclient.execute(httpPut);
                                statusCode = resp.getStatusLine().getStatusCode();
                                entity = resp.getEntity();
                                responseString = EntityUtils.toString(entity, &quot;UTF-8&quot;);

                                if (statusCode == 200 || statusCode == 201) {
                                logger.info(&quot;API Executed succesfully with Status Code ===== &quot; + statusCode)
                                }
                                return responseString;
                                } catch (err) {
                                logger.error(&quot;ERROR Occured while PUT Request&quot; + err);

                                } finally {
                                resp.close();
                                }

                                } else {
                                logger.error(&quot;[API Request Get] : Api Url is not defined in Request Map&quot;)
                                }

                                }

                                function deleteRequest(requestParam,apiAttributes){
                                logger.info(&quot;Inside Delete  Method with requestParams  &quot; +requestParam  + &quot;API attributes&quot; +  apiAttributes )
                                var httpclient = new DefaultHttpClient();

                                // Building the request

                                if (apiAttributes.get(&apos;url&apos;)) {
                                logger.info(&quot;Making Request to Url ==&quot; + apiAttributes.get(&apos;url&apos;))
                                var httpDelete = new HttpDelete(apiAttributes.get(&apos;url&apos;));
                                // Specify Headers which you want to send
                                httpDelete.addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;);

                                apiAttributes.get(&apos;token&apos;) ? httpDelete.addHeader(&quot;x-auth-token&quot;, apiAttributes.get(&apos;token&apos;)) : &quot;&quot;
                                apiAttributes.get(&apos;apiInfo&apos;) ? httpDelete.addHeader(&quot;api-info&quot;, apiAttributes.get(&apos;apiInfo&apos;)) : &quot;&quot;

                                //httpGet.setEntity(new StringEntity(JSON.stringify(requestParam)))

                                var statusCode, entity, responseString, resp
                                try {
                                logger.info(&quot;Going to execute api request &quot;)
                                resp = httpclient.execute(httpDelete);
                                statusCode = resp.getStatusLine().getStatusCode();
                                entity = resp.getEntity();
                                responseString = EntityUtils.toString(entity, &quot;UTF-8&quot;);

                                if (statusCode == 200 &amp;&amp; statusCode == 201) {
                                logger.info(&quot;API Executed succesfully with Status Code ===== &quot; + statusCode)
                                }
                                return responseString;
                                } catch (err) {
                                logger.error(&quot;Error occured while DELETE request&quot; + err);

                                } finally {
                                resp.close();
                                }

                                } else {
                                logger.error(&quot;[API Request Get] : Api Url is not defined in Request Map&quot;)
                                }
                                }


                                function postRequest(requestParam, apiAttributes) {
                                // logger.info(&quot;Inside api request with url &quot; + url + &quot; requestParam==&quot; + requestParam + &quot;Token-===&quot; + token +  &quot;apiInfo&quot; +  apiInfo)
                                var httpclient = new DefaultHttpClient();

                                // Building the request
                                logger.info(&quot;Making Request to Url ==&quot; + apiAttributes.get(&apos;url&apos;))
                                var httpPost = new HttpPost(apiAttributes.get(&apos;url&apos;));
                                // Specify Headers which you want to send
                                httpPost.addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;);


                                apiAttributes.get(&apos;token&apos;) ? httpPost.addHeader(&quot;x-auth-token&quot;, apiAttributes.get(&apos;token&apos;)) : &quot;&quot;
                                apiAttributes.get(&apos;apiInfo&apos;) ? httpPost.addHeader(&quot;api-info&quot;, apiAttributes.get(&apos;apiInfo&apos;)) : &quot;&quot;

                                httpPost.setEntity(new StringEntity(JSON.stringify(requestParam)))

                                var statusCode, entity, responseString, resp
                                try {
                                logger.info(&quot;Going to execute api request &quot;+JSON.stringify(requestParam))
                                resp = httpclient.execute(httpPost);
                                statusCode = resp.getStatusLine().getStatusCode();
                                entity = resp.getEntity();
                                responseString = EntityUtils.toString(entity, &quot;UTF-8&quot;);
                                if (statusCode == 200 || statusCode == 201) {
                                logger.info(&quot;API Executed succesfully with Status Code ===== &quot; + statusCode)
                                }
                                return responseString;
                                } catch (err) {
                                logger.error(&quot;ERROR Executed with POST REQUEST  &quot; + err);

                                } finally {
                                resp.close();
                                }

                                }</code>
      </properties>
    </codeTemplate>
    <codeTemplate version="3.5.0">
      <id>4b933e7c-f206-409b-951b-758c9b4c9442</id>
      <name>checkFieldsToFilter</name>
      <revision>1</revision>
      <lastModified>
        <time>1597059085583</time>
        <timezone>America/New_York</timezone>
      </lastModified>
      <contextSet>
        <delegate>
          <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
          <contextType>DESTINATION_DISPATCHER</contextType>
          <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
          <contextType>SOURCE_RECEIVER</contextType>
          <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
        </delegate>
      </contextSet>
      <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
        <type>FUNCTION</type>
        <code>function  checkFieldsToFilter(msg) {
                                logger.info(&quot;msg : &quot;+msg)
                                var filter = false;
                                var sendingfacility;

                                sendingfacility = msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.1&apos;].toString();
                                if(sendingfacility.search(/SWF_/) &gt; -1){
                                filter = true
                                }

                                return filter;
                                }</code>
      </properties>
    </codeTemplate>
    <codeTemplate version="3.5.0">
      <id>5fb8315d-d5ce-4c14-bb47-2748eeb5729d</id>
      <name>convertCSVPhysName1</name>
      <revision>1</revision>
      <lastModified>
        <time>1597059085677</time>
        <timezone>America/New_York</timezone>
      </lastModified>
      <contextSet>
        <delegate>
          <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
          <contextType>DESTINATION_DISPATCHER</contextType>
          <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
          <contextType>SOURCE_RECEIVER</contextType>
          <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
        </delegate>
      </contextSet>
      <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
        <type>FUNCTION</type>
        <code>/**
                                Modify the description here. Modify the function name and parameters as needed. One function per
                                template is recommended; create a new code template for each new function.

                                @param {String} arg1 - arg1 description
                                @return {String} return description
                                */
                                /**
                                Convert CSV Physician Name
                                */
                                // modify function_name and parameters as you wish.
                                // one function per template is recommended. i.e.) create a new code template for each new function.
                                function convertCSVPhysName1(physName) {
                                var convertedName = new java.util.HashMap()
                                try {
                                logger.info(&quot;The physician name recieved is : &quot; + physName);

                                // write code here.
                                //var salutation = &quot;&quot;;
                                var firstName = &quot;&quot;;
                                var middleName = &quot;&quot;;
                                var lastName = &quot;&quot;;
                                //var listOfSalutations = [&apos;Dr&apos;,&apos;Dr.&apos;,&apos;Mr&apos;,&apos;Mr.&apos;,&apos;Mrs&apos;,&apos;Mrs.&apos;,&apos;Ms&apos;,&apos;Ms.&apos;];


                                var nameArr = physName.split(&quot;,&quot;);

                                //lastName = nameArr[nameArr.length - 1 ];


                                if (nameArr.length == 1) {
                                firstName = nameArr[nameArr.length - 1].trim()
                                } else if(nameArr.length &gt; 2){
                                firstName =   nameArr.splice(1).reverse().join(&quot; &quot;)
                                lastName = nameArr[0].trim()

                                // lastName =  nameArr[0].replace(/,/g, &quot;&quot;)
                                }else{
                                firstName =   nameArr.splice(1).join(&quot; &quot;)
                                lastName = nameArr[0].trim()
                                }

                                convertedName.put(&apos;firstName&apos;, firstName)
                                convertedName.put(&apos;lastName&apos;, lastName)

                                logger.info(&quot;The extracted name is : Last Name = &quot; + convertedName.get(&apos;lastName&apos;) + &quot; First Name = &quot; + convertedName.get(&apos;firstName&apos;));
                                } catch (e) {
                                logger.error(&quot;Exception occured while splitting Name&quot;+e)
                                }

                                return convertedName
                                }</code>
      </properties>
    </codeTemplate>
    <codeTemplate version="3.5.0">
      <id>a8f4327b-e1c0-41b0-afd9-7c3ac15e5f4f</id>
      <name>createAndUpdateUser</name>
      <revision>1</revision>
      <lastModified>
        <time>1597059086118</time>
        <timezone>America/New_York</timezone>
      </lastModified>
      <contextSet>
        <delegate>
          <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
          <contextType>DESTINATION_DISPATCHER</contextType>
          <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
          <contextType>SOURCE_RECEIVER</contextType>
          <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
        </delegate>
      </contextSet>
      <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
        <type>FUNCTION</type>
        <code>/**
                                Modify the description here. Modify the function name and parameters as needed. One function per
                                template is recommended; create a new code template for each new function.

                                @param {String} arg1 - arg1 description
                                @return {String} return description

                                //Send requestMap in function with all required parameters to create User
                                */

                                function createAndUpdateUser(requestMap) {
                                logger.info(&quot;[User Creation] : Inside  User  Creation function &quot;)
                                var userCreate_response = {}
                                try {
                                var userNameandPassword= {}
                                //	var convertedDob =  DateUtil.convertDate(&apos;yyyyMMdd&apos;, &quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss.sss&apos;Z&apos;&quot;, dtStr)
                                var userCreate_json_data={}

                                userCreate_json_data={
                                &quot;username&quot; : requestMap.get(&apos;username&apos;),
                                &quot;firstName&quot;: requestMap.get(&apos;firstName&apos;),
                                &quot;lastName&quot;: requestMap.get(&apos;lastName&apos;),
                                &quot;userType&quot; : requestMap.get(&apos;userType&apos;),
                                &quot;enabled&quot;:true,
                                &quot;activeResource&quot;:{&quot;status&quot;:&quot;ACTIVE&quot;},
                                &quot;email&quot;: requestMap.get(&apos;email&apos;),
                                &quot;phoneNo&quot;: requestMap.get(&apos;phone&apos;),
                                &quot;countryCode&quot;:requestMap.get(&apos;countryCode&apos;),
                                &quot;gender&quot;:requestMap.get(&apos;gender&apos;),
                                &quot;dob&quot;:requestMap.get(&apos;dob&apos;),
                                &quot;prefix&quot;:requestMap.get(&apos;prefix&apos;),
                                &quot;countryCodeFax&quot;:requestMap.get(&apos;countryCodeFax&apos;),
                                &quot;faxNo&quot;:requestMap.get(&apos;faxNo&apos;)
                                }

                                if(requestMap.get(&apos;userId&apos;)){
                                userCreate_json_data.username=requestMap.get(&apos;username&apos;),
                                userCreate_json_data.userGroups=requestMap.get(&apos;userGroups&apos;),
                                userCreate_json_data.id=requestMap.get(&apos;userId&apos;)

                                }else{
                                var passwordCreateMap =  new java.util.HashMap()

                                passwordCreateMap.put(&apos;firstname&apos;,requestMap.get(&apos;firstName&apos;))
                                passwordCreateMap.put(&apos;email&apos;,requestMap.get(&apos;email&apos;))

                                userNameandPassword = GenerateUserNameAndPassword(passwordCreateMap)
                                userCreate_json_data.password  = userNameandPassword.password
                                userCreate_json_data.userGroups = requestMap.get(&apos;userGroups&apos;)
                                }


                                /*  if(userType==&quot;PRACTITIONER&quot;)
                                {

                                }*/

                                //var token = getAuthToken()
                                logger.info(&quot;[User] User creation  map : &quot; + JSON.stringify(userCreate_json_data));
                                var attr = new java.util.HashMap();
                                attr.put(&quot;apiInfo&quot;,JSON.parse(configurationMap.get(&apos;apiInformation&apos;)).apiInfo)
                                attr.put(&quot;token&quot; ,requestMap.get(&apos;token&apos;))
                                attr.put(&quot;url&quot;,requestMap.get(&apos;userCreateUrl&apos;))
                                userCreate_response = apiRequest(&apos;POST&apos;,userCreate_json_data,attr);
                                logger.info(&quot;userCreate_response : &quot; + userCreate_response);
                                userCreate_response = JSON.parse(userCreate_response);

                                if(userCreate_response.httpStatusCode == 200 &amp;&amp; requestMap.get(&apos;userId&apos;) == null) {
                                var notificationMap = new java.util.HashMap()
                                notificationMap.put(&quot;username&quot;,requestMap.get(&apos;username&apos;))
                                notificationMap.put(&quot;userEmail&quot;,requestMap.get(&apos;email&apos;))
                                notificationMap.put(&quot;password&quot;,userNameandPassword.password)
                                notificationMap.put(&quot;token&quot;,requestMap.get(&apos;token&apos;))


                                updateFirstTimePassword(requestMap.get(&apos;username&apos;))
                                /* Uncomment below code to sendNotification after user creation */
                                // var res =sendEmailNotification(notificationMap)
                                //logger.info(&quot;Res Got from Send Notifictaion function is &quot; +  res)
                                }

                                } catch (e) {
                                logger.error(&apos;Exception occured while creating user&apos;+e)
                                }


                                return userCreate_response;
                                }
                            </code>
      </properties>
    </codeTemplate>
    <codeTemplate version="3.5.0">
      <id>66af5541-33a8-4131-9d75-74636033b27b</id>
      <name>createAndUpdateUserGroup</name>
      <revision>1</revision>
      <lastModified>
        <time>1597059085367</time>
        <timezone>America/New_York</timezone>
      </lastModified>
      <contextSet>
        <delegate>
          <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
          <contextType>DESTINATION_DISPATCHER</contextType>
          <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
          <contextType>SOURCE_RECEIVER</contextType>
          <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
        </delegate>
      </contextSet>
      <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
        <type>FUNCTION</type>
        <code>/**
                                Modify the description here. Modify the function name and parameters as needed. One function per
                                template is recommended; create a new code template for each new function.

                                @param {String} arg1 - arg1 description
                                @return {String} return description
                                */

                                function createAndUpdateUserGroup(requestMap){
                                logger.info(&quot;[User Group]: Inside Create User Group function&quot;)
                                //  var token= getAuthToken()
                                // var userGroupSaveUrl = globalMap.get(&quot;minervaUrl&quot;) + JSON.parse(configurationMap.get(&apos;apiInformation&apos;)).userGroupCreate_url
                                var save_response = {}
                                try {
                                var json_data_userGp={}

                                json_data_userGp ={

                                &quot;name&quot;:requestMap.get(&apos;userGroupName&apos;),
                                &quot;organizationId&quot;:requestMap.get(&apos;orgId&apos;),
                                &quot;locationId&quot;:requestMap.get(&apos;location&apos;),
                                &quot;agreements&quot;:[],
                                &quot;menuItems&quot;:requestMap.get(&apos;menuList&apos;),
                                &quot;patientBannerMenuItems&quot;:requestMap.get(&apos;patientBannerList&apos;),
                                &quot;authorities&quot;:requestMap.get(&apos;rolesJson&apos;),
                                }

                                if(requestMap.get(&apos;userGroupId&apos;)){
                                json_data_userGp.id = requestMap.get(&apos;userGroupId&apos;)
                                }

                                var userGp_data = JSON.stringify(json_data_userGp);
                                logger.info(&quot; [User Group Creation] : User Group json data&quot; + userGp_data )
                                var attr= new java.util.HashMap()
                                attr.put(&quot;url&quot;,requestMap.get(&apos;userGroupUrl&apos;))
                                attr.put(&quot;token&quot;,requestMap.get(&apos;token&apos;))
                                attr.put(&quot;apiInfo&quot;,JSON.parse(configurationMap.get(&apos;apiInformation&apos;)).apiInfo)
                                save_response = apiRequest(&apos;POST&apos;,json_data_userGp,attr)
                                logger.info(&quot;User group creation response==== : &quot; + save_response);
                                } catch (e) {
                                logger.error(&quot;Exception Occured while creating user Group&quot;+e)
                                }

                                return save_response

                                }
                            </code>
      </properties>
    </codeTemplate>
    <codeTemplate version="3.5.0">
      <id>b8c9f2ed-afed-47b5-834f-c8eb7bd2586f</id>
      <name>createorUpdateLocation</name>
      <revision>40</revision>
      <lastModified>
        <time>1600249966735</time>
        <timezone>America/New_York</timezone>
      </lastModified>
      <contextSet>
        <delegate>
          <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
          <contextType>DESTINATION_DISPATCHER</contextType>
          <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
          <contextType>SOURCE_RECEIVER</contextType>
          <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
        </delegate>
      </contextSet>
      <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
        <type>FUNCTION</type>
        <code>/**
 Modify the description here. Modify the function name and parameters as needed. One function per
 template is recommended; create a new code template for each new function.

 @param {Any} locationName -
 @param {Any} locIdentifier -
 @param {Any} orgId -
 @param {Any} facilityAddressMap -
 @param {Any} checkLocationStatus -
 @return {String} return description
 */
function getLocationData(locationName, locIdentifier, orgId, facilityAddressMap, checkLocationStatus) {
    logger.info(&quot;[getLocationData] : Inside get Location Function with location Name &quot; + locationName  + &quot;, Organisation Data &quot; + orgId + &quot;, Location Identifier &quot; +locIdentifier);
    logger.info(&quot;[getLocationData] : facilityAddressMap : &quot;+JSON.stringify(facilityAddressMap));
    var returnMap = {};
    returnMap.status = &quot;&quot;;
    returnMap.locationId = null;
    try {
        var locationExist = 0
        var locationReqParams = new java.util.HashMap()
        locationReqParams.put(&apos;keyName&apos;, &apos;identifier.value.value&apos;)
        locationReqParams.put(&apos;keyValue&apos;, locIdentifier)
        var locationData = findDataFromDB(&apos;LOCATION&apos;, locationReqParams)
        if (locationData.totalCount &gt; 0) {
            logger.info(&quot;A LOCATION WITH SAME IDENTIFIER EXISTS&quot;)

            logger.info(&quot;Getting location data from db =======&quot;)
            var cursor = locationData.message
            var lookUpEntry = JSON.parse(cursor.next())

            logger.info(&quot;LOCATION RESOURCE LookUpEntry : &quot;+JSON.stringify(lookUpEntry))

            var locationNameFromDb = lookUpEntry.name ? lookUpEntry.name.value : &quot;&quot;
            if(locationNameFromDb == locationName){
            locationExist = 1
            logger.info(&quot;A LOCATION WITH SAME IDENTIFIER AND LOCATION NAME EXISTS&quot;)
            } else {
            logger.info(&quot;A LOCATION WITH SAME IDENTIFIER EXISTS WITH DIFFERENT LOCATION NAME&quot;)
            returnMap.errMessage = &quot;A LOCATION WITH SAME IDENTIFIER EXISTS WITH DIFFERENT LOCATION NAME&quot;
            returnMap.status = &quot;FAILED&quot;
            }

        } else if(locationName &amp;&amp; locationName!=&quot;&quot;){
            locationReqParams.put(&apos;keyName&apos;, &apos;name.value&apos;)
            locationReqParams.put(&apos;keyValue&apos;, locationName)
            locationData = findDataFromDB(&apos;LOCATION&apos;, locationReqParams)
            if(locationData.totalCount &gt; 0){
                logger.info(&quot;A LOCATION WITH SAME LOCATION NAME EXISTS WITH DIFFERENT IDENTIFIER&quot;)
                returnMap.errMessage = &quot;A LOCATION WITH SAME LOCATION NAME EXISTS WITH DIFFERENT IDENTIFIER&quot;
                returnMap.status = &quot;FAILED&quot;
            }else{
                if(!facilityAddressMap.facilityState || !facilityAddressMap.facilityPostalCode){
					logger.info(&quot;EMPTY_FIELD_FACILITY_STATE_OR_FACILITY_POSTALCODE&quot;)
					returnMap.errMessage = &quot;EMPTY_FIELD_FACILITY_STATE_OR_FACILITY_POSTALCODE&quot;
					returnMap.status = &quot;FAILED&quot;
				}else{
					logger.info(&quot;[Location Creation API] :  Going to Create Location with name &quot; + locationName)
					var locationMap = new java.util.HashMap()
					locationMap.put(&quot;locationName&quot;, locationName)
					locationMap.put(&quot;orgId&quot;, orgId)
					locationMap.put(&quot;locIdentifier&quot;, locIdentifier)
				
					locationMap.put(&quot;facilityAddress&quot;, facilityAddressMap.facilityAddress)
					locationMap.put(&quot;facilityCity&quot;, facilityAddressMap.facilityCity)
					locationMap.put(&quot;facilityState&quot;, facilityAddressMap.facilityState)
					locationMap.put(&quot;facilityPostalCode&quot;, facilityAddressMap.facilityPostalCode)
					var respMap = createOrUpdateLocation(locationMap)
					if(respMap.status != &quot;FAILED&quot;){
						var locres = respMap.location
						if(Object.keys(locres).length &gt; 0){
							logger.info(&quot;LOCATION_CREATED_SUCCESSFULLY : &quot;+locres.id);
							returnMap.errMessage = respMap.errMessage
							returnMap.locationId = locres.id;
							returnMap.id = locres.id;
						}else{
							returnMap.errMessage = &quot;UNABLE_TO_CREATE_LOCATION&quot;
							returnMap.status = &quot;FAILED&quot;
						}
					}else{
						returnMap.errMessage = respMap.errMessage
						returnMap.status = respMap.status
					}
				}
            }
        }
        else{
            logger.info(&quot;LOCATION NAME IS MISSING FOR NEW LOCATION&quot;)
            returnMap.errMessage = &quot;LOCATION NAME IS MISSING FOR NEW LOCATION : &quot;+locationName;
            returnMap.status = &quot;FAILED&quot;
        }
        if(locationExist == 1){

            if(checkLocationStatus == true &amp;&amp; !(lookUpEntry.status &amp;&amp; lookUpEntry.status.value == &quot;active&quot;)){
                returnMap.errMessage = &quot;EXCEPTION_WHILE_GETTING_LOCATION_IDS&quot;
                returnMap.status = &quot;FAILED&quot;
            }
            else{
				var locationAddress = lookUpEntry.address[0].line[0] ? lookUpEntry.address[0].line[0].value : &quot;&quot;
				var locationPostalCode = lookUpEntry.address[0].postalCode ? lookUpEntry.address[0].postalCode.value : &quot;&quot;
				var locationState = lookUpEntry.address[0].state ? lookUpEntry.address[0].state.value : &quot;&quot;
				var locationCity = lookUpEntry.address[0].city ? lookUpEntry.address[0].city.value : &quot;&quot;
				if((facilityAddressMap.facilityAddress == null || facilityAddressMap.facilityAddress == &quot;&quot;) &amp;&amp; (facilityAddressMap.facilityPostalCode == null || facilityAddressMap.facilityPostalCode == &quot;&quot;) &amp;&amp; (facilityAddressMap.facilityState == null || facilityAddressMap.facilityState==&quot;&quot;) &amp;&amp; (facilityAddressMap.facilityCity == null || facilityAddressMap.facilityCity == &quot;&quot;)){
					logger.info(&quot;No update for facility received.&quot;)
					returnMap.locationId = lookUpEntry._id;
					returnMap.id = lookUpEntry._id;
				}else if((locationAddress &amp;&amp;  (facilityAddressMap.facilityAddress == null || facilityAddressMap.facilityAddress == &quot;&quot;) ) || (locationPostalCode &amp;&amp; (facilityAddressMap.facilityPostalCode == null || facilityAddressMap.facilityPostalCode == &quot;&quot;)) || (locationState &amp;&amp; (facilityAddressMap.facilityState == null || facilityAddressMap.facilityState==&quot;&quot;) ) || (locationCity &amp;&amp; (facilityAddressMap.facilityCity == null || facilityAddressMap.facilityCity == &quot;&quot;)) ){
					logger.info(&quot;DETAILS_ALREADY_EXIST_FOR_FEW_FIELDS_OF_FACILITY_THAT_CAME_AS_NULL_IN_UPDATE|UNABLE_TO_UPDATE_LOCATION&quot;)
					returnMap.errMessage = &quot;DETAILS_ALREADY_EXIST_FOR_FEW_FIELDS_OF_FACILITY_THAT_CAME_AS_NULL_IN_UPDATE|UNABLE_TO_UPDATE_LOCATION&quot;
					returnMap.status = &quot;FAILED&quot;
				}else{
					var locationUpdateMap = new java.util.HashMap()
					locationUpdateMap.put(&quot;locationId&quot;, lookUpEntry._id)
					locationUpdateMap.put(&quot;locationName&quot;, lookUpEntry.name.value)
					locationUpdateMap.put(&quot;orgId&quot;, lookUpEntry.managingOrganization)
					locationUpdateMap.put(&quot;locIdentifier&quot;, lookUpEntry.identifier[0].value.value)
					locationUpdateMap.put(&quot;facilityAddress&quot;, facilityAddressMap.facilityAddress)
					locationUpdateMap.put(&quot;facilityCity&quot;, facilityAddressMap.facilityCity)
					locationUpdateMap.put(&quot;facilityState&quot;, facilityAddressMap.facilityState)
					locationUpdateMap.put(&quot;facilityPostalCode&quot;, facilityAddressMap.facilityPostalCode)
					logger.info(&quot;Going to update Location, locationUpdateMap : &quot;+locationUpdateMap)
					var locres = createOrUpdateLocation(locationUpdateMap)
					var respMap = createOrUpdateLocation(locationMap)
					if(respMap.status != &quot;FAILED&quot;){
						var locres = respMap.location
						if(Object.keys(locres).length &gt; 0){
							logger.info(&quot;LOCATION_UPDATED_SUCCESSFULLY : &quot;+locres.id);
							returnMap.errMessage = respMap.errMessage
							returnMap.locationId = locres.id;
							returnMap.id = locres.id;
						}else{
							returnMap.errMessage = &quot;UNABLE_TO_UPDATE_LOCATION&quot;
							returnMap.status = &quot;FAILED&quot;
						}
					}else{
						returnMap.errMessage = respMap.errMessage
						returnMap.status = respMap.status
					}
				}
            }
        }
    } catch (e) {
        logger.error(&quot;Exception Occured while Searching location&quot;+e + e.stack)
        returnMap.errMessage = &quot;EXCEPTION_WHILE_GETTING_LOCATION_DETAILS&quot;
        returnMap.status = &quot;FAILED&quot;
    }
    logger.info(&quot;getLocationData return Map : &quot;+JSON.stringify(returnMap))
    return returnMap
}

function createOrUpdateLocation(requestMap){
	var returnMap = {};
	returnMap.status =&quot;&quot;
    logger.info(&quot;createOrUpdateLocation :  requestMap : &quot;+JSON.stringify(requestMap))
    logger.info(&quot;[Location Creation or Updation API] : Inside Create or Update Location Function with location Name &quot; + requestMap.get(&quot;locationName&quot;))
    var location = {}
    try {
        var requestType = &apos;POST&apos;
        var locationSaveOrUpdateApi
        var location_json={}
        //logger.info(&quot;createOrUpdateLocation : locationSaveOrUpdateApi : &quot; + locationSaveOrUpdateApi)
           var  physicalLocationId
        var facilityAddressText =&quot;&quot;
            var locationReqParams = new java.util.HashMap()
            locationReqParams.put(&apos;keyName&apos;, &apos;identifier.value.value&apos;)
            locationReqParams.put(&apos;keyValue&apos;, requestMap.locIdentifier)
            var locationData = findDataFromDB(&quot;LOCATION&quot;, locationReqParams)

            if(locationData.totalCount &gt;0){
            var cursor = locationData.message
            var lookUpEntry = JSON.parse(cursor.next())
            physicalLocationId  = lookUpEntry._id
            }
        if(requestMap.get(&apos;facilityAddress&apos;) || requestMap.get(&apos;facilityCity&apos;) || requestMap.get(&apos;facilityState&apos;) || requestMap.get(&apos;facilityPostalCode&apos;)){
            
			
			var countryId = &quot;&quot;
			var countrySearchMap = {}
			countrySearchMap[&quot;code&quot;] = &quot;US&quot;
			var countrySearchData = findDataFromDB(&apos;COUNTRIESSET&apos;,countrySearchMap)
			logger.info(&quot;countrySearchData: &quot;+JSON.stringify(countrySearchData))
			if(countrySearchData.totalCount  &amp;&amp; countrySearchData.totalCount == 1){
				var cursor = countrySearchData.message
				var lookUpEntry = JSON.parse(cursor.next())
				countryId = lookUpEntry._id.toString()
			}
			
			var stateId = &quot;&quot;
			var stateCode = &quot;&quot;
			var stateName =&quot;&quot;
			var stateSearchMap = {}
			stateSearchMap[&quot;name&quot;] = requestMap.get(&apos;facilityState&apos;) == &quot;NY&quot; ? &quot;New York&quot;: requestMap.get(&apos;facilityState&apos;) == &quot;NJ&quot; ? &quot;New Jersey&quot; : requestMap.get(&apos;facilityState&apos;)
			stateSearchMap[&quot;country_id&quot;] = countryId
			var StateSearchData = findDataFromDB(&apos;STATESSET&apos;,stateSearchMap)
			if(StateSearchData.totalCount  &amp;&amp; StateSearchData.totalCount == 1){
				var cursor = StateSearchData.message
				var lookUpEntry = JSON.parse(cursor.next())
				stateId = lookUpEntry._id.toString()
				stateCode = lookUpEntry.code
				stateName = lookUpEntry.name
				requestMap.put(&quot;facilityState&quot;,stateCode)
			}else{
				returnMap.errMessage = &quot;STATE DOES NOT EXIST IN DATABASE : &quot;+ requestMap.get(&apos;facilityState&apos;);
				returnMap.status = &quot;FAILED&quot;
				throw(&quot;STATE DOES NOT EXIST IN DATABASE&quot;)
			}

			var cityCode = &quot;&quot;
			var cityName = &quot;&quot;
			var citySearchMap = {}
			citySearchMap[&quot;name&quot;] = requestMap.get(&apos;facilityCity&apos;)
			citySearchMap[&quot;state_id&quot;] = stateId
            var citySearchData = findDataFromDB(&apos;CITIESSET&apos;,citySearchMap)
			if(citySearchData.totalCount  &amp;&amp; citySearchData.totalCount == 1){
				var cursor = citySearchData.message
				var lookUpEntry = JSON.parse(cursor.next())
				cityCode = lookUpEntry.code
				cityName = lookUpEntry.name
				requestMap.put(&quot;facilityCity&quot;, cityCode)
			}else{
				logger.info(&quot;CITY DOES NOT EXIST IN DATABASE&quot;)
				returnMap.errMessage = &quot;CITY DOES NOT EXIST IN DATABASE. FACILITY WILL BE CREATED/UPDATED WITHOUT CITY: &quot;+ requestMap.get(&apos;facilityCity&apos;);
				requestMap.put(&quot;facilityCity&quot;, &quot;&quot;)
			}
			facilityAddressText = requestMap.get(&apos;facilityAddress&apos;)+&quot;, &quot;+cityName+&quot;, &quot;+stateName+&quot;, United States, &quot;+requestMap.get(&apos;facilityPostalCode&apos;)

		}
        //var token =getAuthToken()
        var token = configurationMap.get(&apos;xAuthToken&apos;)
                if(requestMap.get(&quot;locationId&quot;)){
                var locationSaveOrUpdateApi = globalMap.get(&quot;minervaUrl&quot;) + JSON.parse(configurationMap.get(&apos;apiInformation&apos;)).locationUpdateUrl + requestMap.get(&quot;locationId&quot;)
            requestType = &apos;PUT&apos;
            if(requestMap.get(&apos;facilityAddress&apos;) || requestMap.get(&apos;facilityCity&apos;) || requestMap.get(&apos;facilityState&apos;) || requestMap.get(&apos;facilityPostalCode&apos;)){
                location_json.address=[{&quot;line&quot;:[requestMap.get(&apos;facilityAddress&apos;),&quot;&quot;], &quot;state&quot;:requestMap.get(&quot;facilityState&quot;),&quot;postalCode&quot;:requestMap.get(&quot;facilityPostalCode&quot;),&quot;city&quot;:requestMap.get(&quot;facilityCity&quot;),&quot;country&quot;:&quot;US&quot;,&quot;text&quot;:facilityAddressText}]
            }
            if(requestMap.get(&quot;locationName&quot;) != &quot;SIUH&quot;){
            location_json.partOf = {&quot;id&quot;: physicalLocationId}
            }
        }else{
                    var locationSaveOrUpdateApi = globalMap.get(&quot;minervaUrl&quot;) + JSON.parse(configurationMap.get(&apos;apiInformation&apos;)).locationCreateUrl

            location_json={
                &quot;mode&quot;:JSON.parse(configurationMap.get(&apos;locationInfo&apos;)).locationMode,
                &quot;name&quot;:{&quot;value&quot;: requestMap.get(&quot;locationName&quot;)},
            &quot;identifier&quot;:[{&quot;system&quot;:{&quot;value&quot;:globalMap.get(&quot;custName&quot;)},&quot;value&quot;:requestMap.get(&quot;locIdentifier&quot;),&quot;useCode&quot;:&quot;usual&quot;,&quot;type&quot;:{&quot;text&quot;:&quot;performingLocationId&quot;}}],
                &quot;description&quot;:&quot;\n&quot;,
                &quot;telecom&quot;:[],
                &quot;status&quot;:&quot;active&quot;,
                &quot;visible&quot;:false,
                &quot;partOf&quot;:{&quot;id&quot;: physicalLocationId},
                &quot;managingOrganization&quot;: {&quot;id&quot;: requestMap.get(&quot;orgId&quot;)},
                &quot;type&quot;:JSON.parse(configurationMap.get(&apos;locationInfo&apos;)).locationType,
                &quot;physicalType&quot;:JSON.parse(configurationMap.get(&apos;locationInfo&apos;)).physicalType,
                &quot;address&quot;:[{&quot;line&quot;:[requestMap.get(&apos;facilityAddress&apos;),&quot;&quot;], &quot;state&quot;:requestMap.get(&quot;facilityState&quot;),&quot;postalCode&quot;:requestMap.get(&quot;facilityPostalCode&quot;),&quot;city&quot;:requestMap.get(&quot;facilityCity&quot;),&quot;country&quot;:&quot;US&quot;,&quot;text&quot;:facilityAddressText}]
            }
        }

        logger.info(&quot;[Location Creation or Updation API] :  Location Creation or Updation JSON is &quot; + JSON.stringify(location_json))

        var attr = new java.util.HashMap()
        attr.put(&quot;url&quot;,locationSaveOrUpdateApi)
        attr.put(&quot;token&quot;,token)

        var locationResponse= apiRequest(requestType,location_json,attr)
        logger.info(&quot;[Location Creation or Updation API] : Location Creation or Updation Response from API is &quot; + locationResponse)
        location=JSON.parse(locationResponse)
		returnMap.location = location

    } catch (e) {
        logger.error(&quot;Exception Occured while Creating or Updating location&quot;+e)
		
    }

    return returnMap
}</code>
      </properties>
    </codeTemplate>
    <codeTemplate version="3.5.0">
      <id>06f6d32d-6417-4519-97ef-78c44d8165fa</id>
      <name>createPractitioner</name>
      <revision>3</revision>
      <lastModified>
        <time>1597232860188</time>
        <timezone>America/New_York</timezone>
      </lastModified>
      <contextSet>
        <delegate>
          <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
          <contextType>DESTINATION_DISPATCHER</contextType>
          <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
          <contextType>SOURCE_RECEIVER</contextType>
          <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
        </delegate>
      </contextSet>
      <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
        <type>FUNCTION</type>
        <code>/**
                                Modify the description here. Modify the function name and parameters as needed. One function per
                                template is recommended; create a new code template for each new function.

                                @param {String} arg1 - arg1 description
                                @return {String} return description
                                */
                                function createPractitioner(requestMap){
                                var telecomList = new Packages.java.util.ArrayList()
                                var practitionerRoleList=  new Packages.java.util.ArrayList()
                                var pracResponse = {}
                                try {
                                var telecomData= {}
                                if(requestMap.get(&apos;physPhone&apos;)){
                                telecomData= {}
                                telecomData.countryCode=requestMap.get(&apos;countryCode&apos;),
                                telecomData.primary=true
                                telecomData.system=&quot;phone&quot;
                                telecomData.useCode= &quot;Home Phone&quot;,
                                telecomData.value=requestMap.get(&apos;physPhone&apos;)
                                }

                                telecomList.add(telecomData)
                                if(requestMap.get(&apos;physEmail&apos;)){
                                telecomData= {}
                                telecomData.primary=true
                                telecomData.system=&quot;email&quot;
                                telecomData.useCode= &quot;work&quot;,
                                telecomData.value= requestMap.get(&apos;physEmail&apos;)
                                }
                                telecomList.add(telecomData)

                                var practitioner_json={}

                                var addressString = requestMap.get(&apos;address&apos;) + &quot; &quot; +  requestMap.get(&apos;city&apos;) + &quot;  &quot; + requestMap.get(&apos;state&apos;) +  &quot; &quot;+  requestMap.get(&apos;postalCode&apos;) +&quot; &quot; +  requestMap.get(&apos;country&apos;)

                                practitioner_json={
                                &quot;active&quot;:true,
                                &quot;gender&quot;:requestMap.get(&apos;physGender&apos;),
                                &quot;identifier&quot;:[{&quot;system&quot;:{&quot;value&quot;:configurationMap.get(&apos;assigningAuthority&apos;)},&quot;type&quot;:{&quot;coding&quot;:[{&quot;code&quot;:configurationMap.get(&apos;typeCode&apos;)}],&quot;text&quot;:&quot;Person Number&quot;},&quot;useCode&quot;:&quot;usual&quot;,&quot;value&quot;:requestMap.get(&apos;physIdentifier&apos;)},{&quot;system&quot;:{&quot;value&quot;:&quot;Tax Id&quot;},&quot;type&quot;:{&quot;coding&quot;:[{&quot;code&quot;:&quot;TIN&quot;}],&quot;text&quot;:&quot;Tax ID Number&quot;},&quot;useCode&quot;:&quot;usual&quot;,&quot;value&quot;:requestMap.get(&apos;tinNo&apos;)}],
                                &quot;name&quot;:[{&quot;family&quot;:requestMap.get(&apos;physLastName&apos;),&quot;given&quot;:requestMap.get(&apos;physFirstName&apos;),&quot;period&quot;:null,&quot;prefix&quot;:[],&quot;suffix&quot;:[],&quot;text&quot;:requestMap.get(&apos;physName&apos;),&quot;useCode&quot;:&quot;Human Name&quot;}],
                                &quot;practitionerRole&quot;:[{&quot;specialty&quot;:[],&quot;role&quot;:{&quot;text&quot;:&quot;&quot;},&quot;managingOrganization&quot;:{&quot;id&quot;:requestMap.get(&apos;orgId&apos;)}}],
                                &quot;location&quot;:requestMap.get(&apos;location&apos;),
                                &quot;telecom&quot;:telecomList
                                /*&quot;telecom&quot;:telecomList,
                                &quot;address&quot;: [{ &quot;country&quot;: requestMap.get(&apos;country&apos;),
                                &quot;extension&quot;: [],
                                &quot;period&quot;: null,
                                &quot;city&quot;: requestMap.get(&apos;city&apos;),
                                &quot;line&quot;:[requestMap.get(&apos;address&apos;)],
                                &quot;postalCode&quot;: requestMap.get(&apos;postalCode&apos;),
                                &quot;state&quot;:requestMap.get(&apos;state&apos;),
                                &quot;text&quot;: addressString
                                }
                                ]*/

                                }
                                if(!requestMap.get(&apos;tinNo&apos;)){
                                practitioner_json.identifier = [{&quot;system&quot;:{&quot;value&quot;:configurationMap.get(&apos;assigningAuthority&apos;)},&quot;type&quot;:{&quot;coding&quot;:[{&quot;code&quot;:configurationMap.get(&apos;typeCode&apos;)}],&quot;text&quot;:&quot;Person Number&quot;},&quot;useCode&quot;:&quot;usual&quot;,&quot;value&quot;:requestMap.get(&apos;physIdentifier&apos;)}]
                                }

                                logger.info(&quot;[Practitioner Creation API] : &quot;)

                                logger.info(&quot;[Practitioner Creation API] : practitioner_json for API is  &quot; + JSON.stringify(practitioner_json) + requestMap.get(&apos;practitionerUrl&apos;))
                                var attr= new java.util.HashMap()
                                attr.put(&quot;url&quot;,requestMap.get(&apos;practitionerUrl&apos;))
                                attr.put(&quot;token&quot;,requestMap.get(&apos;token&apos;))
                                //  attr.put(&apos;apiInfo&apos;,configurationMap.get(&apos;apiInfo&apos;))
                                if(!requestMap.get(&apos;physId&apos;)){
                                pracResponse=apiRequest(&apos;POST&apos;,practitioner_json,attr)
                                }else{
                                practitioner_json.id=requestMap.get(&apos;physId&apos;)
                                pracResponse=apiRequest(&apos;PUT&apos;,practitioner_json,attr)
                                }


                                } catch (e) {
                                logger.error(&quot;Exception Occured while Creating Practitioner&quot;+e)
                                }

                                return JSON.parse(pracResponse)
                                }</code>
      </properties>
    </codeTemplate>
    <codeTemplate version="3.5.0">
      <id>bd04a698-bbad-4721-b3a0-579e6159404b</id>
      <name>createPractitionerViaMFNAndAPI</name>
      <revision>84</revision>
      <lastModified>
        <time>1600848312752</time>
        <timezone>America/New_York</timezone>
      </lastModified>
      <contextSet>
        <delegate>
          <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
          <contextType>DESTINATION_DISPATCHER</contextType>
          <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
          <contextType>SOURCE_RECEIVER</contextType>
          <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
        </delegate>
      </contextSet>
      <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
        <type>FUNCTION</type>
        <code>/**
 Modify the description here. Modify the function name and parameters as needed. One function per
 template is recommended; create a new code template for each new function.

 @param {Any} action -
 @param {Any} msg -
 @return {String} return description
 */
function createPractitionerViaMFNAndAPI(action,msg){
    globalMap.put(&apos;pracReport&apos;,&quot;&quot;)
    if(action == &apos;MFN&apos;) {
        var result=null
        var count = 0
        result= createPractitionerMFN(msg,count)
        logger.info(&quot;[Practitioner MFN Creation]  : Result got from Processing MFN message &quot; + result)

        return result;
    }

    if(action == &apos;API&apos;){
        var result={}
        var count = 0
        result= createPractitionerAPI(msg,count)
        logger.info(&quot;[Practitioner API  Creation] : Result got from processing data via API&quot; + JSON.stringify(result))
        return result
    }

}


function createPractitionerMFN(msg,count){
    logger.info(&quot;[Practitioner Creation] : Inside createPractitionerMFN with Data &quot; + msg)
    var messageString = &quot;&quot;;

    try {
        var dateTimeTmp = new java.util.Date();
        var origfilename = sourceMap.get(&apos;originalFilename&apos;);
        var insertion_source = &quot;MIRTH&quot;;
        var eventType = &quot;M02&quot;;
        var report = &apos;&apos;
        for each (seg in msg.children()) {
            var errMessage = &quot;&quot;;
            var status = &quot;&quot;;
            if(count==0){
                report = report + (SerializerFactory.getSerializer(&apos;DELIMITED&apos;).fromXML(seg)).replace(&apos;\n&apos;,&apos;&apos;) +&quot;,Status,Filter Reason\n&quot;;
                logger.info(&quot;Header information &quot;+(SerializerFactory.getSerializer(&apos;DELIMITED&apos;).fromXML(seg)).replace(&apos;\n&apos;,&apos;&apos;));
            }else{
                logger.info(&quot;[Create Practitioner MFN] :  Iterating over Segments to create MFN message&quot;)

                var physicianName = convertCSVPhysName1(seg[&apos;physicianName&apos;].toString())
                var physicianIdentifier = seg[&apos;physicianEmail&apos;].trim()?seg[&apos;physicianEmail&apos;].trim().toString().toLowerCase():&quot;&quot;
                var physicianEmail =  seg[&apos;physicianEmail&apos;].trim()?seg[&apos;physicianEmail&apos;].trim().toString().toLowerCase() :&quot;&quot;
                var physicianSurname=  physicianName.get(&apos;lastName&apos;)
                var physicianFirstName =   physicianName.get(&apos;firstName&apos;)
                var physicianPhoneNumber=seg[&apos;physicianPhone&apos;].trim()?seg[&apos;physicianPhone&apos;].trim().toString():&quot;&quot;
                var physicianGender=seg[&apos;physicianGender&apos;].trim()?seg[&apos;physicianGender&apos;].trim().toString():&quot;&quot;
                var physicianLocation=seg[&apos;physicianLocation&apos;].trim()?seg[&apos;physicianLocation&apos;].trim().toString().split(configurationMap.get(&apos;locationDelimiter&apos;)) : []
                var physicianLocationIdentifier=seg[&apos;physicianLocationIdentifier&apos;].trim()?seg[&apos;physicianLocationIdentifier&apos;].trim().toString().split(configurationMap.get(&apos;locationDelimiter&apos;)) : []
                var dept = seg[&apos;Dept&apos;].trim() ? seg[&apos;Dept&apos;].trim().toString() : &quot;&quot;


                var pracValidateMap = new java.util.HashMap()
                pracValidateMap.put(&apos;physicianFirstName&apos;,physicianFirstName)
                pracValidateMap.put(&apos;physicianSurname&apos;,physicianSurname)
                pracValidateMap.put(&apos;physicianEmail&apos;,physicianEmail)
                pracValidateMap.put(&apos;physicianPhone&apos;,physicianPhoneNumber)
                pracValidateMap.put(&apos;physicianLocation&apos;,physicianLocation)
                pracValidateMap.put(&apos;physicianLocationIdentifier&apos;,physicianLocationIdentifier)
                pracValidateMap.put(&apos;physicianResidentifier&apos;,physicianIdentifier)
                var filterFlag = filterCSVData(pracValidateMap)

                if(filterFlag.flag == true)	{
                    var msgNew = &lt;HL7Message/&gt;;
                    createSegment(&apos;MSH&apos;, msgNew);
                    msgNew.MSH[&apos;MSH.1&apos;] = &apos;|&apos;;
                    msgNew.MSH[&apos;MSH.2&apos;] = &apos;^~\\^&apos;;
                    msgNew.MSH[&apos;MSH.3&apos;][&apos;MSH.3.1&apos;] = &apos;MINERVA&apos;;
                    msgNew.MSH[&apos;MSH.4&apos;][&apos;MSH.4.1&apos;] = &apos;MPHRX&apos;;
                    msgNew.MSH[&apos;MSH.5&apos;][&apos;MSH.5.1&apos;] = &apos;MPHRX&apos;;
                    msgNew.MSH[&apos;MSH.6&apos;][&apos;MSH.6.1&apos;] = &apos;MPHRX&apos;;
                    msgNew.MSH[&apos;MSH.6&apos;][&apos;MSH.6.2&apos;] = &apos;MPHRX&apos;
                    msgNew.MSH[&apos;MSH.9&apos;][&apos;MSH.9.1&apos;] = &apos;MFN&apos;;
                    msgNew.MSH[&apos;MSH.9&apos;][&apos;MSH.9.2&apos;] = eventType;
                    msgNew.MSH[&apos;MSH.10&apos;][&apos;MSH.10.1&apos;] = &apos;123455&apos;;
                    msgNew.MSH[&apos;MSH.11&apos;][&apos;MSH.11.1&apos;] = &apos;D&apos;;
                    msgNew.MSH[&apos;MSH.12&apos;][&apos;MSH.12.1&apos;] = &apos;2.5&apos;;


                    createSegment(&apos;MFI&apos;, msgNew);
                    msgNew.MFI[&apos;MFI.1&apos;][&apos;MFI.1.1&apos;] = &apos;PRA&apos;;
                    //msgNew.MFI[&apos;MFI.2&apos;][&apos;MFI.2.1&apos;] = &quot;RAD_INTERLOCUTORES&quot;;
                    msgNew.MFI[&apos;MFI.3&apos;][&apos;MFI.3.1&apos;] = &quot;UPD&quot;;
                    msgNew.MFI[&apos;MFI.6&apos;][&apos;MFI.6.1&apos;] = &quot;AL&quot;;

                    createSegment(&apos;MFE&apos;, msgNew);
                    msgNew.MFE[&apos;MFE.1&apos;][&apos;MFE.1.1&apos;] = &apos;MUP&apos;;


                    createSegment(&apos;STF&apos;, msgNew);
                    msgNew.STF[&apos;STF.2&apos;][&apos;STF.2.1&apos;] = physicianIdentifier;
                    msgNew.STF[&apos;STF.3&apos;][&apos;STF.3.1&apos;] = physicianSurname;
                    msgNew.STF[&apos;STF.3&apos;][&apos;STF.3.2&apos;] = physicianFirstName;
                    msgNew.STF[&apos;STF.5&apos;][&apos;STF.5.1&apos;] =  physicianGender;
                    msgNew.STF[&apos;STF.10&apos;][&apos;STF.10.1&apos;] = physicianPhoneNumber;
                    msgNew.STF[&apos;STF.15&apos;][&apos;STF.15.1&apos;] = physicianEmail;
                    logger.info(&quot;[Prcatitioner creation MFN] : Going to create MFN  Messages by Location&quot;)


                    for  (loc in physicianLocation,physicianLocationIdentifier) {
                        logger.info(&quot;[Practitioner Creation MFN ] Location Fetched is &quot;+ physicianLocation[loc])
                        var msgPra = &lt;HL7Message/&gt;;
                        createSegment(&apos;PRA&apos;, msgPra);
                        msgPra.PRA[&apos;PRA.1&apos;][&apos;PRA.1.1&apos;] = &apos;01&apos;;
                        msgPra.PRA[&apos;PRA.2&apos;][&apos;PRA.2.2&apos;]=physicianLocationIdentifier[loc]
                        msgPra.PRA[&apos;PRA.3&apos;][&apos;PRA.3.1&apos;] = &quot;E&quot;;
                        //msgNew.PRA[&apos;PRA.5&apos;][&apos;PRA.5.1&apos;] = specialtyId;
                        msgPra.PRA[&apos;PRA.6&apos;][&apos;PRA.6.1&apos;] = physicianIdentifier;
                        msgPra.PRA[&apos;PRA.6&apos;][&apos;PRA.6.2&apos;] =configurationMap.get(&apos;assigningAuthority&apos;);
                        msgPra.PRA[&apos;PRA.6&apos;][&apos;PRA.6.3&apos;] =configurationMap.get(&apos;typeCode&apos;)

                        var topSeg = msgNew.copy();
                        topSeg.appendChild(msgPra)
                        topSeg.MSH[&apos;MSH.6&apos;][&apos;MSH.6.1&apos;] = physicianLocationIdentifier[loc];
                        topSeg.MSH[&apos;MSH.6&apos;][&apos;MSH.6.2&apos;] = physicianLocation[loc]
                        var mesg = SerializerFactory.getSerializer(&apos;HL7V2&apos;).fromXML(topSeg);
                        logger.info(&quot;[Practitioner Creation MFN] Final MFN Message Created is &quot;+mesg)
                        messageString = messageString + mesg
                        //messageList.add(mesg)
                        status = &quot;SUCCESS&quot;
                    }
                }else{
                    status = &quot;FAILED&quot;
                    errMessage = filterFlag.errorMsg;
                }

                report = report + (SerializerFactory.getSerializer(&apos;DELIMITED&apos;).fromXML(seg)).replace(&apos;\n&apos;,&apos;&apos;) +&quot;,&quot;+status+&quot;,&quot;+errMessage+&quot;\n&quot;;
            }
            count ++;

        }
        globalMap.put(&apos;pracReport&apos;,report)
    } catch (e) {
        logger.error(&quot;Exception Occured in creating practitioner via MFn&quot;+e + e.stack)
    }
    return messageString;
}


function createPractitionerAPI(msg,count){
    logger.info(&quot;Inside createPractitionet  Api&quot;)
    var result = {}
    var report =&apos;&apos;
    var reportMap = {}
    reportMap.errMessage = &quot;&quot;;
    reportMap.status = &quot;&quot;;
    reportMap.wrgMessage = &quot;&quot;;
    reportMap.wrgstatus = &quot;&quot;;
    var pracRes=null
    try {
        for each (seg in msg.children()){
            if(count==0){
                report = report + (SerializerFactory.getSerializer(&apos;DELIMITED&apos;).fromXML(seg)).replace(&apos;\n&apos;,&apos;&apos;) +&quot;,Status,Filter Reason\n&quot;;
                logger.info(&quot;Header information &quot;+(SerializerFactory.getSerializer(&apos;DELIMITED&apos;).fromXML(seg)).replace(&apos;\n&apos;,&apos;&apos;));
            }else{
                try{
                    logger.info(&quot;[Practitioner Creation API]  : Reading CSV values for Practitioner creation &quot;)
                    //var token = getAuthToken()
                    var token = configurationMap.get(&apos;xAuthToken&apos;)
                    var locations = new Packages.java.util.ArrayList()
                    var orgData=null
                    var physicianName = convertCSVPhysName1(seg[&apos;physicianName&apos;].toString())

                    var physicianSurname=  physicianName.get(&apos;lastName&apos;) ?physicianName.get(&apos;lastName&apos;).trim() : &quot;&quot;
                    var physicianFirstName =   physicianName.get(&apos;firstName&apos;) ? physicianName.get(&apos;firstName&apos;).trim(): &quot;&quot;
                    var physicianEmail = seg[&apos;physicianEmail&apos;].trim()?seg[&apos;physicianEmail&apos;].trim().toString().toLowerCase():&quot;&quot;
                    var physicianPhone = seg[&apos;physicianPhone&apos;].trim()?seg[&apos;physicianPhone&apos;].trim().toString():&quot;&quot;
                    var physicianGender = seg[&apos;physicianGender&apos;].trim()?seg[&apos;physicianGender&apos;].trim().toString():&quot;&quot;
                    var physicianDob=seg[&apos;physicianDob&apos;].trim()?seg[&apos;physicianDob&apos;].trim().toString():&quot;&quot;
                    var physicianLocation=  seg[&apos;physicianLocation&apos;].trim().toString()?seg[&apos;physicianLocation&apos;].toString().split(configurationMap.get(&apos;locationDelimiter&apos;)):[]
            physicianLocation = trimListValue(physicianLocation)
                    var physicianLocationIdentifier=seg[&apos;physicianLocationIdentifier&apos;]?seg[&apos;physicianLocationIdentifier&apos;].toString().trim().split(configurationMap.get(&apos;locationDelimiter&apos;)):[]
            physicianLocationIdentifier = trimListValue(physicianLocationIdentifier)
                    var physicianResidentifier = seg[&apos;physicianResidentifier&apos;].trim()?seg[&apos;physicianResidentifier&apos;].trim().toString():&quot;&quot;
                    var dept = seg[&apos;Dept&apos;].trim() ? seg[&apos;Dept&apos;].trim().toString() : &quot;&quot;
                    var physCountryCode= seg[&apos;countryCode&apos;].trim() ? seg[&apos;countryCode&apos;].trim().toString() :configurationMap.get(&apos;defaultCountryCode&apos;).toString()
                    physCountryCode = getCountryCodePrefix(new java.lang.String(physCountryCode))
                    var physCompleteName =  physicianFirstName + &quot; &quot; + physicianSurname
                    var state =  seg[&apos;state&apos;].trim() ? seg[&apos;state&apos;].trim().split(configurationMap.get(&apos;locationDelimiter&apos;)):[]
            state = trimListValue(state)
                    var city = seg[&apos;city&apos;].trim() ? seg[&apos;city&apos;].trim().split(configurationMap.get(&apos;locationDelimiter&apos;)):[]
            city = trimListValue(city)
                    var postalCode = seg[&apos;postalCode&apos;].trim() ?  seg[&apos;postalCode&apos;].trim().split(configurationMap.get(&apos;locationDelimiter&apos;)):[]
            postalCode = trimListValue(postalCode)
                    var address = seg[&apos;address&apos;].trim() ? seg[&apos;address&apos;].trim().split(configurationMap.get(&apos;locationDelimiter&apos;)):[]
            address = trimListValue(address)
                    var tinNo = seg[&apos;tinNo&apos;].trim() ? seg[&apos;tinNo&apos;].trim().toString() : &quot;&quot;
                    var npi = seg[&apos;npi&apos;].trim() ? seg[&apos;npi&apos;].trim().toString() : &quot;&quot;
                    var isSurgeonTin = seg[&apos;isSurgeonTin&apos;] ?  (seg[&apos;isSurgeonTin&apos;].toString().trim().match(/^[Yy]$/) ? true : false) : false


                    logger.info(&quot;[Practitioner Creation API] : Practitioner Data got from CSV is Name&quot; + physicianName + &quot;Email &quot; + physicianEmail + &quot;Phone is &quot; + physicianPhone+ &quot;Gender &quot; + physicianGender + &quot;Location is &quot; + physicianLocation + &quot;Location Identfier is &quot; + physicianLocationIdentifier
                        + &quot; Physician Identifier is  &quot; + physicianResidentifier + &quot;country Code is &quot; +physCountryCode)

                    var pracValidateMap = new java.util.HashMap()
                    pracValidateMap.put(&apos;physicianFirstName&apos;,physicianFirstName)
                    pracValidateMap.put(&apos;physicianSurname&apos;,physicianSurname)
                    pracValidateMap.put(&apos;physicianEmail&apos;,physicianEmail)
                    pracValidateMap.put(&apos;physicianPhone&apos;,physicianPhone)
                    pracValidateMap.put(&apos;physicianLocation&apos;,physicianLocation)
                    pracValidateMap.put(&apos;physicianLocationIdentifier&apos;,physicianLocationIdentifier)
                    pracValidateMap.put(&apos;physicianResidentifier&apos;,physicianResidentifier)

                    var validateResponse = filterCSVData(pracValidateMap)

                    if(validateResponse.flag==true){
                        if(token){
                            if(npi &amp;&amp; npi!=&quot;&quot;){
                                physicianResidentifier = npi.toString()
                            }else if(physicianResidentifier &amp;&amp; physicianResidentifier!=&quot;&quot;){
                                physicianResidentifier = physicianResidentifier
                            }

                            var pracFindMap = {}

                            pracFindMap[&quot;identifier.value.value&quot;] = physicianResidentifier
                            pracFindMap[&quot;telecom.value.value&quot;] = physicianEmail
                            var practitionerSearchData = findDataFromDB(&apos;PRACTITIONER&apos;,pracFindMap,&quot;OR&quot;)
                            logger.info(&quot;[Practitioner Creation API]: Practitioner Search Data is &quot; + JSON.stringify(practitionerSearchData))
                            var phyUniquenessMap = phyUniquenessCheck(practitionerSearchData,physicianEmail,physicianResidentifier,tinNo)
                            if(phyUniquenessMap.isValid &amp;&amp; practitionerSearchData.totalCount==0){
                            	 var closeMatchCheckFlag =  configurationMap.get(&apos;isCloseMatchCheckenabledPractitioner&apos;)
                            	 logger.info(&quot;CloseMatch Check Flag &quot; + closeMatchCheckFlag)
                            if(closeMatchCheckFlag == &quot;true&quot;){
                            	logger.info(&quot;Inside Match Flag&quot; + closeMatchCheckFlag)

                            	 	 var closeMatchMap = closeMatchCheck(physicianFirstName,physicianSurname);
                            	 	   reportMap.status = closeMatchMap.status;
                                      reportMap.errMessage = closeMatchMap.errMessage;
                            	 }
                               
                           
                             
                                logger.info(&quot;[Practitioner Creation API] : Going to create Practitioner&quot;)
                                orgData = findOrganisation()

                                var locLeng = physicianLocationIdentifier.length;
                                if(((reportMap.status) &amp;&amp; (reportMap.status != &quot;FAILED&quot;)) &amp;&amp; (locLeng != address.length ||locLeng != city.length ||locLeng != state.length ||locLeng != postalCode.length) ){
                                    //status = &quot;FAILED&quot;;
                                    logger.info(&quot;LOCATION_ADDRESS_COUNT_MISMATCH&quot;);
                                }
                                if(((reportMap.status)  &amp;&amp; (reportMap.status != &quot;FAILED&quot;)) &amp;&amp; (locLeng ==0 || (physicianLocation.length&gt;0 &amp;&amp; locLeng != physicianLocation.length))){
                                    status = &quot;FAILED&quot;;
                                    errMessage = &quot;LOCATION_ID_IS_EMPTY OR LOCATION_ID_AND_LOCATION_NAME COUNT_MISMATCH&quot;;
                                }
                                else if(reportMap.status != &quot;FAILED&quot;){
                                    logger.info(&quot;Length is &quot; + physicianLocationIdentifier.length)
                                    for(index=0; (index &lt; locLeng &amp;&amp; reportMap.status != &quot;FAILED&quot;); index++){
                                        var locMap= {};
                                        var facilityAddressMap = {}
                                        facilityAddressMap.facilityAddress = address.length &gt; index ? address[index] : &quot;&quot;;
                                        facilityAddressMap.facilityCity = city.length &gt; index ? city[index] : &quot;&quot;;
                                        facilityAddressMap.facilityState = state.length &gt; index ? state[index] : &quot;&quot;;
                                        facilityAddressMap.facilityPostalCode = postalCode.length &gt; index ? postalCode[index] : &quot;&quot;;

                                        locMap = getLocationData((physicianLocation.length &gt; index ? physicianLocation[index] : &quot;&quot;),physicianLocationIdentifier[index],orgData,facilityAddressMap,true)
                                        locations.add({&quot;id&quot;:locMap.locationId})
                                        reportMap.status = locMap.status ? locMap.status : &quot;&quot;;
                                        reportMap.errMessage = locMap.errMessage ? locMap.errMessage : &quot;&quot;;
                                    }
                                }else{
                                    logger.info(&quot;Can&apos;t find Location, status is FAILED : reportMap &quot;+ JSON.stringify(reportMap));
                                }
                                logger.info(&quot;NEW PHYSICIAN CASE : OUTPUT from  getLocationData method : &quot;+JSON.stringify(reportMap))
                                if(reportMap.status != &quot;FAILED&quot; &amp;&amp; physCompleteName &amp;&amp; physicianEmail &amp;&amp; physicianPhone &amp;&amp; locations &amp;&amp; physicianResidentifier &amp;&amp; orgData){
                                    var pracSaveUrl =globalMap.get(&quot;minervaUrl&quot;)  + JSON.parse(configurationMap.get(&apos;apiInformation&apos;)).practitionerSaveUrl
                                    var practCreateReqMap = new java.util.HashMap()
                                    practCreateReqMap.put(&quot;physFirstName&quot;,physicianFirstName)
                                    practCreateReqMap.put(&quot;physLastName&quot;,physicianSurname)
                                    practCreateReqMap.put(&quot;physName&quot;, physCompleteName)
                                    practCreateReqMap.put(&quot;physEmail&quot;,physicianEmail)
                                    practCreateReqMap.put(&quot;physPhone&quot;,physicianPhone)
                                    practCreateReqMap.put(&quot;physGender&quot;,physicianGender)
                                    practCreateReqMap.put(&quot;location&quot;,locations)
                                    practCreateReqMap.put(&quot;countryCode&quot;,physCountryCode)
                                    practCreateReqMap.put(&quot;physIdentifier&quot;,physicianResidentifier)
                                    practCreateReqMap.put(&quot;orgId&quot;,orgData)
                                    practCreateReqMap.put(&quot;practitionerUrl&quot;,pracSaveUrl)
                                    practCreateReqMap.put(&quot;token&quot;,token)
                                    //practCreateReqMap.put(&quot;country&quot;,country)
                                    //practCreateReqMap.put(&quot;state&quot;,state)
                                    //practCreateReqMap.put(&quot;city&quot;,city)
                                    //practCreateReqMap.put(&quot;postalCode&quot;,postalCode)
                                    //practCreateReqMap.put(&quot;address&quot;,address)
                                    if(isSurgeonTin){
                                        practCreateReqMap.put(&quot;tinNo&quot;,tinNo)
                                    }
                                    pracRes=createPractitioner(practCreateReqMap)

                                    logger.info(&quot;Practitioner response &quot; + pracRes)
                                    if(Object.keys(pracRes).length &gt; 0){
                                        result.flag=true
                                        result.statusCode=200
                                        reportMap.status = &quot;SUCCESS&quot;
                                        logger.info(&quot;SUCCESSFULLY SAVED PRACTITIONER&quot;)
                                    }else{
                                        result.flag=false
                                        result.statusCode=500
                                        reportMap.errMessage = &quot;EXCEPTION_WHILE_CREATING_PRACTITIONER&quot;
                                        reportMap.status = &quot;FAILED&quot;
                                        logger.info(&quot;Error occurred while creating practitioner&quot;)
                                    }

                                }
                                else if(reportMap.status != &quot;FAILED&quot;){
                                    reportMap.status = &quot;FAILED&quot;
                                    reportMap.errMessage = &quot;FAILED_TO_CREATE_PHYISICIAN : &quot;
                                    reportMap.errMessage = physCompleteName ? reportMap.errMessage : &quot;,physCompleteName : &quot;+ physCompleteName
                                    reportMap.errMessage = physicianEmail ? reportMap.errMessage : &quot;,physicianEmail : &quot;+ physicianEmail
                                    reportMap.errMessage = physicianPhone ? reportMap.errMessage : &quot;,physicianPhone : &quot;+physicianPhone
                                    reportMap.errMessage = locations ? reportMap.errMessage : &quot;,locations : &quot;+locations
                                    reportMap.errMessage = physicianResidentifier ? reportMap.errMessage : &quot;,physicianResidentifier : &quot;+physicianResidentifier
                                    reportMap.errMessage = orgData ? reportMap.errMessage : &quot;,orgData : &quot;+orgData

                                }

                            }
                            else if (phyUniquenessMap.isValid &amp;&amp; practitionerSearchData.totalCount==1){
                                logger.info(&quot;[Practitioner Creation API] :  Practitioner Update Comes&quot;)

                                var physId= phyUniquenessMap._id
                                orgData = findOrganisation()
                                locations = new Packages.java.util.ArrayList()
                                var locLeng = physicianLocationIdentifier.length;

                                logger.info(&quot;TOTAL LOCATION COUNT IS : &quot;+locLeng+&quot;, existing locations are : &quot;+phyUniquenessMap.locationIdList);

                                if((reportMap.status != &quot;FAILED&quot;) &amp;&amp; (locLeng != address.length ||locLeng != city.length ||locLeng != state.length ||locLeng != postalCode.length) ){
                                    //status = &quot;FAILED&quot;;
                                    logger.info(&quot;LOCATION_ADDRESS_COUNT_MISMATCH&quot;);
                                }
                                if((reportMap.status != &quot;FAILED&quot;) &amp;&amp; (locLeng ==0 || (physicianLocation.length&gt;0 &amp;&amp; locLeng != physicianLocation.length))){
                                    status = &quot;FAILED&quot;;
                                    errMessage = &quot;LOCATION_ID_IS_EMPTY OR LOCATION_ID_AND_LOCATION_NAME COUNT_MISMATCH&quot;;
                                }
                                else if(reportMap.status != &quot;FAILED&quot;){
                                    logger.info(&quot;Length is &quot; + physicianLocationIdentifier.length)
                                    for(index=0; (index &lt; locLeng &amp;&amp; reportMap.status != &quot;FAILED&quot;); index++){
                                        var locMap= {};
                                        var facilityAddressMap = {}
                                        facilityAddressMap.facilityAddress = address.length &gt; index ? address[index] : &quot;&quot;;
                                        facilityAddressMap.facilityCity = city.length &gt; index ? city[index] : &quot;&quot;;
                                        facilityAddressMap.facilityState = state.length &gt; index ? state[index] : &quot;&quot;;
                                        facilityAddressMap.facilityPostalCode = postalCode.length &gt; index ? postalCode[index] : &quot;&quot;;

                                        locMap = getLocationData((physicianLocation.length &gt; index ? physicianLocation[index] : &quot;&quot;),physicianLocationIdentifier[index],orgData,facilityAddressMap,true)
                                        if(phyUniquenessMap.locationIdList &amp;&amp; reportMap.locationId &amp;&amp; phyUniquenessMap.locationIdList.indexOf(reportMap.locationId) &lt; 0){
                                            reportMap.errMessage = &quot;NEW_LOCATION_ID_NOT_PERMITTED : MONGO_ID : &quot;+locationDataMap.id
                                            reportMap.status = &quot;FAILED&quot;;
                                            break;
                                        }else{
                                            locations.add({&quot;id&quot;:locMap.locationId})
                                        }
                                        reportMap.status = locMap.status ? locMap.status : &quot;&quot;;
                                        reportMap.errMessage = locMap.errMessage ? locMap.errMessage : &quot;&quot;;
                                    }
                                }else{
                                    logger.info(&quot;Can&apos;t find Location, status is FAILED : reportMap &quot;+ JSON.stringify(reportMap));
                                }

                                logger.info(&quot;FOR EXISTING PHYSICIAN : OUTPUT from  getLocationData method : &quot;+JSON.stringify(reportMap))

                    var pracUpdateUrl= globalMap.get(&quot;minervaUrl&quot;)  + JSON.parse(configurationMap.get(&apos;apiInformation&apos;)).practitionerUpdateUrl + physId
                                if( reportMap.status != &quot;FAILED&quot; &amp;&amp; physId &amp;&amp; physCompleteName &amp;&amp; physicianEmail &amp;&amp; physicianPhone  &amp;&amp; locations &amp;&amp; physicianResidentifier &amp;&amp; orgData){
                                    var practCreateReqMap = new java.util.HashMap()
                                    practCreateReqMap.put(&quot;physFirstName&quot;,physicianFirstName)
                                    practCreateReqMap.put(&quot;physLastName&quot;,physicianSurname)
                                    practCreateReqMap.put(&quot;physId&quot;,physId)
                                    practCreateReqMap.put(&quot;physName&quot;, physCompleteName)
                                    practCreateReqMap.put(&quot;physEmail&quot;,physicianEmail)
                                    practCreateReqMap.put(&quot;physPhone&quot;,physicianPhone)
                                    practCreateReqMap.put(&quot;physGender&quot;,physicianGender)
                                    practCreateReqMap.put(&quot;location&quot;,locations)
                                    practCreateReqMap.put(&quot;physIdentifier&quot;,physicianResidentifier)
                                    practCreateReqMap.put(&quot;orgId&quot;,orgData)
                                    practCreateReqMap.put(&quot;practitionerUrl&quot;,pracUpdateUrl)
                                    practCreateReqMap.put(&quot;token&quot;,token)
                                    practCreateReqMap.put(&quot;countryCode&quot;,physCountryCode)
                                    //practCreateReqMap.put(&quot;country&quot;,country)
                                    //practCreateReqMap.put(&quot;state&quot;,state)
                                    //practCreateReqMap.put(&quot;city&quot;,city)
                                    //practCreateReqMap.put(&quot;postalCode&quot;,postalCode)
                                    if(isSurgeonTin){
                                        practCreateReqMap.put(&quot;tinNo&quot;,tinNo)
                                    }
                                    //practCreateReqMap.put(&quot;address&quot;,address)
                                    pracRes=createPractitioner(practCreateReqMap)

                                    if(Object.keys(pracRes).length &gt; 0){
                                        result.flag=true
                                        result.statusCode=200
                                        reportMap.status = &quot;SUCCESS&quot;
                                    }else{
                                        result.flag=false
                                        result.statusCode=500
                                        reportMap.errMessage = &quot;EXCEPTION_WHILE_UPDATING_PRACTITIONER&quot;
                                        reportMap.status = &quot;FAILED&quot;
                                        logger.info(&quot;Error occurred while updating practitioner&quot;)
                                    }
                                }
                                else if(reportMap.status != &quot;FAILED&quot;){
                                    //logger.info(physId +&quot; : &quot;+&quot; : &quot;+ physCompleteName +&quot; : &quot;+&quot; : &quot;+ physicianEmail +&quot; : &quot;+&quot; : &quot;+ physicianPhone  +&quot; : &quot;+&quot; : &quot;+ locations +&quot; : &quot;+&quot; : &quot;+ physicianResidentifier +&quot; : &quot;+&quot; : &quot;+ orgData)
                                    reportMap.status = &quot;FAILED&quot;
                                    reportMap.errMessage = &quot;FAILED_TO_UPDATE_PHYISICIAN : &quot;
                                    reportMap.errMessage = physId ? reportMap.errMessage : &quot;,physId : &quot;+ physId
                                    reportMap.errMessage = physCompleteName ? reportMap.errMessage : &quot;,physCompleteName : &quot;+ physCompleteName
                                    reportMap.errMessage = physicianEmail ? reportMap.errMessage : &quot;,physicianEmail : &quot;+ physicianEmail
                                    reportMap.errMessage = physicianPhone ? reportMap.errMessage : &quot;,physicianPhone : &quot;+physicianPhone
                                    reportMap.errMessage = locations ? reportMap.errMessage : &quot;,locations : &quot;+locations
                                    reportMap.errMessage = physicianResidentifier ? reportMap.errMessage : &quot;,physicianResidentifier : &quot;+physicianResidentifier
                                    reportMap.errMessage = orgData ? reportMap.errMessage : &quot;,orgData : &quot;+orgData
                                }

                            }
                            else{
                                result.flag=false
                                result.statusCode=500
                                reportMap.errMessage = phyUniquenessMap.errorMsg
                                reportMap.status = &quot;FAILED&quot;

                            }
                        }else{
                            logger.error(&quot;[Practitioner Creation API] : Error Occured while Getting Token&quot;)
                            reportMap.errMessage = &quot;EXCEPTION_WHILE_GETTING_TOKEN&quot;
                            reportMap.status = &quot;FAILED&quot;
                            //report = report + (SerializerFactory.getSerializer(&apos;DELIMITED&apos;).fromXML(seg)).replace(&apos;\n&apos;,&apos;&apos;) +&quot;, Error Occured while geeting token from  login API \n&quot;;
                        }

                    }else{
                        reportMap.status = &quot;FAILED&quot;
                        reportMap.errMessage = validateResponse.errorMsg;

                    }

                    logger.info(&quot;DATA_PROCESSED_STATUS : &quot;+reportMap.status +&quot;, MESSAGE : &quot;+reportMap.errMessage +&quot; WRG_STATUS : &quot;+reportMap.wrgstatus +&quot;, WRG_MESSAGE : &quot;+reportMap.wrgMessage)

                    if(reportMap.wrgMessage != undefined &amp;&amp; reportMap.wrgMessage != &quot;&quot;){
                        reportMap.errMessage = reportMap.errMessage + &quot; | &quot;+ reportMap.wrgMessage
                        if(reportMap.status == &quot;SUCCESS&quot;){
                            reportMap.status = &quot;WARNING&quot;
                        }
                    }
                    if(reportMap.errMessage == undefined){
                        reportMap.errMessage = &quot;&quot;;
                    }
                }
                catch(e){
                    logger.error(&quot;EXCEPTION : &quot;+e);
                    reportMap.status = &quot;FAILED&quot;;
                    reportMap.errMessage = reportMap.errMessage+&quot; | &quot;+e;
                }

                report = report + (SerializerFactory.getSerializer(&apos;DELIMITED&apos;).fromXML(seg)).replace(&apos;\n&apos;,&apos;&apos;) +&quot;,&quot;+reportMap.status+&quot;,&quot;+reportMap.errMessage+&quot;\n&quot;;
            }

            count ++
        }
        globalMap.put(&apos;pracReport&apos;,report)
    } catch (e) {
        logger.info(&quot;DATA_PROCESSED_STATUS : &quot;+reportMap.status +&quot;, MESSAGE : &quot;+reportMap.errMessage)
        logger.error(&apos;Exception Occured while creating practitioner via API&apos;+e + e.stack)
    }


    return result
}



function findOrganisation(){
    var orgId = &quot;&quot;
    try {
        var orgFindMap = new java.util.HashMap()
        orgFindMap.put(&quot;keyName&quot;,&apos;name.value&apos;)
        orgFindMap.put(&quot;keyValue&quot;,configurationMap.get(&apos;organisation&apos;))

        var organizationData=findDataFromDB(&apos;ORGANIZATION&apos;,orgFindMap)
        logger.info(&quot;=============Organization Data is &quot; + JSON.stringify(organizationData))
        if(organizationData.totalCount&gt;0){
            logger.info(&quot;[Practitioner Creation API] : Going to find Organization Id&quot;)
            orgId = getId(organizationData)
            logger.info(&quot;[Practitioner Creation API] : Organization Id is &quot;+ orgId)
        }
    } catch (e) {
        logger.error(&quot;Exception Occured while finding Organisation&quot;+e + e.stack)
    }

    return orgId;
}


function getId(jsonData,collectionName) {
    var dataId;
    try {
        logger.info(&quot;[Practitioner Creation API] : Going to search id &quot;)
        var cursor =jsonData.message
        var lookUpEntry=JSON.parse(cursor.next())
        if(collectionName == &quot;LOCATION&quot;){
            dataId = (lookUpEntry.status &amp;&amp; lookUpEntry.status.value == &quot;active&quot;) ? lookUpEntry._id : &quot;NOT_VALID : &quot;+ lookUpEntry._id
        }
        else{
            dataId = lookUpEntry._id;
        }
    } catch (e) {
        logger.error(&apos;Exception Occured while getting id&apos;+e + e.stack)
    }
    return dataId
}

function phyUniquenessCheck(jsonData,physicianEmail,physicianResidentifier,tinNo){
    var returnMap = {}
    returnMap.isValid = false
    returnMap.errorMsg = &quot;&quot;;

    if(!jsonData || jsonData.totalCount == undefined){
        logger.info(&quot;ERROR_WHILE_FETCHING_PHYSICIAN&quot;)
        returnMap.errorMsg = &quot;ERROR_WHILE_FETCHING_PHYSICIAN&quot;
        returnMap.isValid = false
    }
    else if(jsonData.totalCount == 0){
        logger.info(&quot;NO_PHYSICIAN_FOUND&quot;)
        returnMap.isValid = true
    }
    else if(jsonData.totalCount &gt; 1){
        logger.info(&quot;MULTIPLE_PHYSICIAN_FOUND&quot;)
        returnMap.errorMsg = &quot;MULTIPLE_PHYSICIAN_FOUND_WITH_SAME_EMAIL_OR_NPI&quot;
        returnMap.isValid = false
    }
    else{
        logger.info(&quot;ONE_PHYSICIAN_FOUND&quot;)
        try {
            var cursor =jsonData.message
            var lookUpEntry=JSON.parse(cursor.next())
            logger.info(&quot;Working for Physician Id : &quot;+lookUpEntry._id);
            var tinNumFound = false;
            var sameTinFound = false;
            var npiFound = false

            for(index in lookUpEntry.identifier){
                if(lookUpEntry.identifier[index].value &amp;&amp; lookUpEntry.identifier[index].value.value == physicianResidentifier ){
                    logger.info(&quot;PHYSICIAN_FOUND_WITH_NPI : &quot;+physicianResidentifier)
                    npiFound = true
                    returnMap.isValid = true
                    returnMap.phyNPI = lookUpEntry.identifier[index].value.value
                    returnMap._id = lookUpEntry._id
                    returnMap.locationIdList = lookUpEntry.location ? lookUpEntry.location : []
                }
                if(lookUpEntry.identifier[index].type &amp;&amp; lookUpEntry.identifier[index].type.coding &amp;&amp; lookUpEntry.identifier[index].type.coding[0].code.value == &quot;TIN&quot;){
                    tinNumFound = true;
                    if(lookUpEntry.identifier[index].value &amp;&amp; lookUpEntry.identifier[index].value.value == tinNo){
                        logger.info(&quot;TIN_NUMBER_MATCHED : &quot;+lookUpEntry.identifier[index].value.value )
                        sameTinFound = true;
                    }
                }
            }
            if(tinNumFound){
                if(!sameTinFound){
                    logger.info(&quot;DIFFERENT TIN FOUND : &quot;)
                    returnMap.isValid = false;
                    returnMap.errorMsg = &quot;DIFFERENT_TIN_FOUND_IN_PRACTITIONER : &quot;+ tinNo
                    returnMap.status = &quot;FAILED&quot;
                }
            }
            if(!npiFound){
                returnMap.isValid = false;
                returnMap.errorMsg = &quot;OTHER_PRACTITIONER_FOUND_WITH_SAME_EMAIL : &quot;+ lookUpEntry._id
                returnMap.status = &quot;FAILED&quot;
            }
        } catch (e) {
            logger.error(&apos;Exception while parsing practitioner response&apos;+e + e.stack)
            returnMap.errorMsg = &quot;EXCEPTION_WHILE_PARSING_RESPONSE&quot;
            returnMap.isValid = false
        }

    }
    logger.info(&quot;phyUniquenessCheck : &quot; + JSON.stringify(returnMap) )
    return returnMap

}

function filterCSVData(requestMap){

    var filter = {&quot;flag&quot; : true , &quot;errorMsg&quot; :&quot;&quot;}
    var error = &quot;&quot;
    try {
        logger.info(requestMap.get(&apos;physicianLocation&apos;)+ &quot;Value is &quot; + requestMap.get(&apos;physicianLocation&apos;).length + &quot;locationIdentifier is &quot;+requestMap.get(&apos;physicianLocationIdentifier&apos;)+&quot;===========&quot; +requestMap.get(&apos;physicianLocationIdentifier&apos;).length)
        var locationNameLength = requestMap.get(&apos;physicianLocation&apos;).length;
        var locationIdentifierLength = requestMap.get(&apos;physicianLocationIdentifier&apos;).length;

        if(locationIdentifierLength==0 || (locationNameLength!=0 &amp;&amp; locationNameLength!=locationIdentifierLength)){
            filter.flag=false
            filter.errorMsg=&quot;LOC_IDENTIFIER_AND_LOC_NAME_COUNT_MISMATCH&quot;
            return filter
        }else{

            if(!requestMap.get(&apos;physicianEmail&apos;) || (requestMap.get(&apos;physicianEmail&apos;) &amp;&amp; !(	requestMap.get(&apos;physicianEmail&apos;).match(/^[\w\.\-]+([\w\.\-]+)*\@[\w\.\-]+\.[\w]{2,}$/)))){
                //	filter.flag=false
                error= requestMap.get(&apos;physicianEmail&apos;) ? &quot;PHYSICIAN_EMAIL_IS_INVALID&quot; : &quot;PHYSICIAN_EMAIL_IS_EMPTY&quot;;
            }


            if(!requestMap.get(&apos;physicianPhone&apos;) ||  (requestMap.get(&apos;physicianPhone&apos;)  &amp;&amp;  !(requestMap.get(&apos;physicianPhone&apos;).match(/^[1-9][0-9]{9}$/)))){
                error= requestMap.get(&apos;physicianPhone&apos;) ? &quot;PHYSICIAN_PHONE_IS_INVALID : CHAR_SET_OUT_OF [1-9][0-9]{9}&quot; : &quot;PHYSICIAN_PHONE_IS_EMPTY&quot;;
            }

            for each (loc in requestMap.get(&apos;physicianLocationIdentifier&apos;)){
                if(!loc || loc==null ||loc==&quot;&quot;||loc.toLowerCase()==&quot;null&quot;){
                    error=&quot;LOCATION_ID_IS_INVALID&quot;
                }
            }

            if(! requestMap.get(&apos;physicianResidentifier&apos;)|| requestMap.get(&apos;physicianResidentifier&apos;)==&quot;&quot;){
                error=requestMap.get(&apos;physicianResidentifier&apos;) ? &quot;PHYSICIAN_IDENTIFIER_IS_INVALID&quot; : &quot;PHYSICIAN_IDENTIFIER_IS_EMPTY&quot;;
            }
        }


        if(error || error!=&quot;&quot;){
            filter.flag = false
            filter.errorMsg =  error

        }

    } catch (e) {
        logger.error(&apos;Exception Occured while filtering CSv Data&apos; + e + e.stack);
        filter.flag = false
        filter.errorMsg = &quot;ERROR_IN_PARSING_MESSAGE&quot;
    }

    return filter;
}

function closeMatchCheck(firstName, lastName) {
logger.info(&quot;======================&quot;)
    var returnMap = {&quot;errMessage&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;}
    var pracFindMap = {}

    //var firstNameLen = firstName.length()
    //var lastNameLen = lastName.length()
    //var regexString = &quot;&quot;
    logger.info(firstName.length()+&quot;------&quot;+lastName.length())
    if(firstName.length()&gt;=4){
        firstName = firstName.substring(0,4).toString()
    }
    if(lastName.length() &gt;= 4){
        lastName = lastName.substring(lastName.length() -4,lastName.length()).toString()
    }

    var regexString = &quot;^&quot;+firstName.toLowerCase()+&quot;.*&quot;+lastName.toLowerCase()+&quot;$&quot;

    logger.info(&quot;regexString :&quot;+regexString+&quot; Type:&quot;+typeof(regexString))
    pracFindMap[&quot;lowerCaseName.text.value&quot;] = {&quot;$regex&quot;:regexString.toString()}

    //pracFindMap[&quot;lowerCaseName.text.value&quot;] = {&quot;$regex&quot;:firstName.toLowerCase()}
    //pracFindMap[&quot;lowerCaseName.text.value&quot;] = {&quot;$regex&quot;:lastName.toLowerCase()}
    try{
        var  pracResource = findDataFromDB(&apos;PRACTITIONER&apos;,pracFindMap,&quot;OR&quot;)
        if(pracResource.totalCount  &amp;&amp; pracResource.totalCount &gt; 0){
            logger.info(&quot;FOUND_MULTIPLE_PHYSICIAN_WITH_SIMILAR_NAME&quot;+pracResource)
            returnMap = {&quot;errMessage&quot;:&quot;FOUND_MULTIPLE_PHYSICIAN_WITH_SIMILAR_NAME : &quot;+getId(pracResource),&quot;status&quot;:&quot;FAILED&quot;}
        }
    }
    catch(ex){
        logger.error(&quot;EXCEPTION_WHILE_FETCHING_CLOSE_MATCH_OF_PHYSICIAN&quot;+ex + ex.stack)
        returnMap = {&quot;errMessage&quot;:&quot;EXCEPTION_WHILE_FETCHING_CLOSE_MATCH_OF_PHYSICIAN&quot;,&quot;status&quot;:&quot;FAILED&quot;}
    }
    logger.info(&quot;Return Map&quot; +  returnMap)

    return returnMap
}
</code>
      </properties>
    </codeTemplate>
    <codeTemplate version="3.5.0">
      <id>2578df28-48a8-4bb0-8f6f-f3ab2d70ea6f</id>
      <name>createUserViaCSV</name>
      <revision>35</revision>
      <lastModified>
        <time>1600853128033</time>
        <timezone>America/New_York</timezone>
      </lastModified>
      <contextSet>
        <delegate>
          <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
          <contextType>DESTINATION_DISPATCHER</contextType>
          <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
          <contextType>SOURCE_RECEIVER</contextType>
          <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
        </delegate>
      </contextSet>
      <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
        <type>FUNCTION</type>
        <code>/**
 Modify the description here. Modify the function name and parameters as needed. One function per
 template is recommended; create a new code template for each new function.

 @param {Any} row -
 @param {Any} status -
 @param {Any} errMessage -
 @return {Any}
 */
function createUserViaCSV(row, status, errMessage ){
    logger.info(&quot;createUserViaCSV : Working for CSV Row : &quot;+JSON.stringify(row));
    var userValidateMap = new java.util.HashMap()
    userValidateMap.put(&apos;firstName&apos;, row.firstName)
    userValidateMap.put(&apos;lastName&apos;, row.lastName)
    userValidateMap.put(&apos;email&apos;, row.email)
    userValidateMap.put(&apos;phone&apos;, row.phone)
    userValidateMap.put(&apos;userGroupName&apos;, row.userGroupName)
    userValidateMap.put(&apos;gender&apos;, row.gender)
    userValidateMap.put(&apos;locationName&apos;, row.locationName)
    userValidateMap.put(&apos;locationIdentifier&apos;, row.locationIdentifier)
    userValidateMap.put(&apos;resourceidentifier&apos;, row.resourceidentifier)
    userValidateMap.put(&apos;userType&apos;, row.userType)
    logger.info(&quot;createUserViaCSV UserValidationMap : &quot;+userValidateMap)

    var validateRes = validateData_User(userValidateMap)
    if (validateRes.flag == true) {
        // var token = getAuthToken()
        var token = configurationMap.get(&apos;xAuthToken&apos;)
        var userCreation_result = {}
        var userGroupCreateMap = new java.util.HashMap()

        if (token) {
            var userGroupId = null
            var userGroupReqParams = {}//new java.util.HashMap()
            userGroupReqParams[&apos;name&apos;] = row.userGroupName;

            var userGroupCreationMap = JSON.parse(configurationMap.get(&apos;userGroupCreationMap&apos;))
            logger.info(&quot;userGroupReqParams:&quot; + userGroupReqParams)
            var userGroupSerach_res = findDataFromDB(&apos;USERGROUP&apos;, userGroupReqParams)

            if (userGroupSerach_res.totalCount == 0) {
                userGroupCreateMap.put(&quot;userGroupName&quot;, row.userGroupName)
                userGroupCreateMap.put(&quot;locationName&quot;, row.locationName)
                userGroupCreateMap.put(&quot;locationIdentifier&quot;, row.locationIdentifier)
                userGroupCreateMap.put(&quot;userGroupType&quot;, row.userGroupType)
                userGroupCreateMap.put(&quot;facilityAddress&quot;, row.facilityAddress)
                userGroupCreateMap.put(&quot;facilityCity&quot;, row.facilityCity)
                userGroupCreateMap.put(&quot;facilityState&quot;, row.facilityState)
                userGroupCreateMap.put(&quot;facilityPostalCode&quot;, row.facilityPostalCode)

                logger.info(&quot;createUserViaCSV : userGroupCreateMap : &quot;+userGroupCreateMap)

                var result = createUserGroupvViaCSV_User(userGroupCreateMap, token, null)
                var res = JSON.parse(result);

                if (status != &quot;FAILED&quot; &amp;&amp; res.httpStatusCode == 200) {
                    logger.info(&quot;User Group Creation Successful&quot;)
                    var userGroupSerach_res = findDataFromDB(&apos;USERGROUP&apos;, userGroupReqParams)
                    var cursor = userGroupSerach_res.message
                    var lookUpEntry = JSON.parse(cursor.next())
                    userGroupId = lookUpEntry._id
                    logger.info(&quot;Got usergroup as :&quot;+JSON.stringify(lookUpEntry))
                    userGroupCreateMap.put(&quot;userGroupName&quot;, row.userGroupName)
                    userGroupCreateMap.put(&quot;locationName&quot;, row.locationName)
                    userGroupCreateMap.put(&quot;locationIdentifier&quot;, row.locationIdentifier)
                    userGroupCreateMap.put(&quot;userGroupType&quot;, row.userGroupType)
                    userGroupCreateMap.put(&quot;facilityAddress&quot;, row.facilityAddress)
                    userGroupCreateMap.put(&quot;facilityCity&quot;, row.facilityCity)
                    userGroupCreateMap.put(&quot;facilityState&quot;, row.facilityState)
                    userGroupCreateMap.put(&quot;facilityPostalCode&quot;, row.facilityPostalCode)
                    logger.info(&quot;Test3 : &quot;+userGroupCreateMap)
                    logger.info(&quot;Test3 : &quot;+row.facilityAddress)

                    if (row.userGroupType in userGroupCreationMap) {
                        userGroupCreateMap.put(&quot;userGroupId&quot;, userGroupId)
                        var res = createUserGroupvViaCSV_User(userGroupCreateMap, token,null)
                    }
                } else if (status != &quot;FAILED&quot;) {
                    status = &quot;FAILED&quot;
                    errMessage = &quot;FAILED_TO_CREATE_USERGROUP : &quot; + JSON.stringify(res)
                }

            } else {
                logger.info(&quot;User Group already exists.Going to find user group Id&quot;)
                var cursor = userGroupSerach_res.message
                var lookUpEntry = JSON.parse(cursor.next())
                userGroupId = lookUpEntry._id
                userGroupCreateMap.put(&quot;userGroupName&quot;, row.userGroupName)
                userGroupCreateMap.put(&quot;locationName&quot;, row.locationName)
                userGroupCreateMap.put(&quot;locationIdentifier&quot;, row.locationIdentifier)
                userGroupCreateMap.put(&quot;userGroupType&quot;, row.userGroupType)
                userGroupCreateMap.put(&quot;facilityAddress&quot;, row.facilityAddress)
                userGroupCreateMap.put(&quot;facilityCity&quot;, row.facilityCity)
                userGroupCreateMap.put(&quot;facilityState&quot;, row.facilityState)
                userGroupCreateMap.put(&quot;facilityPostalCode&quot;, row.facilityPostalCode)
                logger.info(&quot;Test3 : &quot;+userGroupCreateMap)
                logger.info(&quot;Test3 : &quot;+row.facilityAddress)

                if (row.userGroupType in userGroupCreationMap) {
                    userGroupCreateMap.put(&quot;userGroupId&quot;, userGroupId)
                    var res = createUserGroupvViaCSV_User(userGroupCreateMap, token, lookUpEntry)
                    logger.info(&quot;User Group updated sucessFully&quot; + JSON.stringify(res))
                }

                logger.info(&quot;Got User Group ID:   &quot; + userGroupId)

            }

            if (userGroupId) {
                var userGroupIdList = new java.util.ArrayList()
                userGroupIdList.add(userGroupId)
                logger.info(&quot;Going to search whether the user exists or not with email &quot; + row.email)
                var userReqParams = {}
                userReqParams[&apos;username&apos;] = row.username
                var userSearch_res = findDataFromDB(&apos;USER&apos;, userReqParams)
                logger.info(&quot;User Search response &quot; + userSearch_res)

                var createUserRequestMap = new java.util.HashMap()
                createUserRequestMap.put(&quot;firstName&quot;, row.firstName)
                createUserRequestMap.put(&quot;lastName&quot;, row.lastName)
                createUserRequestMap.put(&quot;email&quot;, row.email)
                createUserRequestMap.put(&quot;phone&quot;, row.phone)
                createUserRequestMap.put(&quot;dob&quot;, row.dob)
                createUserRequestMap.put(&quot;gender&quot;, row.gender)
                createUserRequestMap.put(&quot;userType&quot;, row.userType)
                createUserRequestMap.put(&quot;token&quot;, token)
                createUserRequestMap.put(&apos;countryCode&apos;, row.countryCode)
                createUserRequestMap.put(&apos;prefix&apos;, row.prefix)
                createUserRequestMap.put(&apos;countryCodeFax&apos;, row.countryCodeFax)
                createUserRequestMap.put(&apos;faxNo&apos;, row.faxNo)
                createUserRequestMap.put(&apos;username&apos;, row.username)

                if (userSearch_res.totalCount == 0) {
                    var userSaveUrl = globalMap.get(&quot;minervaUrl&quot;) + JSON.parse(configurationMap.get(&apos;apiInformation&apos;)).userCreate_url
                    createUserRequestMap.put(&quot;userGroups&quot;, userGroupIdList)
                    createUserRequestMap.put(&quot;userCreateUrl&quot;, userSaveUrl)
                    createUserRequestMap.put(&apos;userId&apos;, null)

                    	 var closeMatchCheckFlag =  configurationMap.get(&apos;isCloseMatchCheckEnabledUser&apos;)
                           logger.info(&quot;CloseMatch Check Flag &quot; + closeMatchCheckFlag)
                            if(closeMatchCheckFlag == &quot;true&quot;){ 	 	
                            	 	var closeMatchMap = closeMatchCheck_User(row.firstName, row.lastName)
                                   errMessage = closeMatchMap.errMessage
                                   status = closeMatchMap.status
                            	 }
                    

                    if (status != &quot;FAILED&quot; &amp;&amp; (row.firstName != &quot;&quot; || row.lastName != &quot;&quot; || row.email != &quot;&quot;)) {
                        userCreation_result = createAndUpdateUser(createUserRequestMap)
                        if (userCreation_result.httpStatusCode == 200) {
                            logger.info(&quot;[User Creation Successful&quot;)
                            status = &quot;SUCCESS&quot;
                        } else {
                            status = &quot;FAILED&quot;
                            errMessage = &quot;ERROR_OCCURRED_WHILE_USER_CREATION : &quot; + userCreation_result ? JSON.stringify(userCreation_result) : userCreation_result
                        }
                    } else if (status != &quot;FAILED&quot;) {
                        status = &quot;FAILED&quot;
                        errMessage = &quot;ERROR_MANDATORY_FIELDS_ARE_EMPTY : &quot;
                        errMessage = row.firstName ? errMessage + &quot;,firstName : &quot; + row.firstName : errMessage
                        errMessage = row.lastName ? errMessage + &quot;,lastName : &quot; + row.lastName : errMessage
                        errMessage = row.email ? errMessage + &quot;,email : &quot; + row.email : errMessage
                    }

                } else {
                    var cursor = userSearch_res.message
                    var lookUpEntry = JSON.parse(cursor.next())

                    if (lookUpEntry.userGroups.indexOf(userGroupId) &gt;= 0) {
                        logger.info(&quot;[User Creation] :  User Group Id already exist in user Not going to update&quot;)
                        status = &quot;FAILED&quot;
                        errMessage = &quot;USER_GROUP_ALREADY_EXISTS_IN_USER : &quot; + lookUpEntry._id
                    } else {
                        logger.info(&quot;Going to update usergroup : &quot;+userGroupIdList+&quot;, in user : &quot;+lookUpEntry._id)

                        var userUpdateUrl = globalMap.get(&quot;minervaUrl&quot;) + JSON.parse(configurationMap.get(&apos;apiInformation&apos;)).userUpdateUrl
                        for (id in lookUpEntry.userGroups) {
                            userGroupIdList.add(lookUpEntry.userGroups[id])
                        }

                        createUserRequestMap.put(&apos;username&apos;, lookUpEntry.username)
                        createUserRequestMap.put(&apos;userGroups&apos;, userGroupIdList)
                        createUserRequestMap.put(&apos;userCreateUrl&apos;, userUpdateUrl)
                        createUserRequestMap.put(&apos;userId&apos;, lookUpEntry._id)
                        createUserRequestMap.put(&apos;id&apos;, lookUpEntry._id)
                        userCreation_result = createAndUpdateUser(createUserRequestMap)
                        if(userCreation_result &amp;&amp; (userCreation_result.httpStatusCode == 200 || userCreation_result.httpStatusCode == &quot;200&quot;) )
                        {
                            status = &quot;SUCCESS&quot;
                        }
                        else{
                            status = &quot;FAILED&quot;;
                            errMessage = userCreation_result ? JSON.stringify(userCreation_result) : &quot;UNABLE_TO_CREATE_USER : &quot;+userCreation_result
                        }
                        //errMessage = &quot;ADDING_NEW_USER_GROUP_IS_NOT_PERMITTED : If you want to add another User Group Please contact System Administrator&quot;
                    }
                }
            } else {
                logger.error(&quot;[User Group] : User group Id not found &quot;)
                status = &quot;FAILED&quot;
                errMessage = &quot;FAILED_TO_UPDATE_USER_GROUP : &quot; + userGroupId
            }
        } else {
            status = &quot;FAILED&quot;
            errMessage = &quot;EXCEPTION_WHILE_GETTING_TOKEN&quot;
        }

    } else {
        status = &quot;FAILED&quot;
        errMessage = validateRes.errorMsg;
    }

    var returnMap = {
        &quot;status&quot; : status,
        &quot;errMessage&quot; : errMessage
    }
    return returnMap
}

function createUserGroupvViaCSV_User(userGroupMap, token , lookUpEntry ) {
    logger.info(&quot;Test4 : &quot;+userGroupMap)
    logger.info(&quot;[User Group Creation] :  Inside createUserGroupvViaCSV_User function with userGroupMap ==&quot; + userGroupMap)
    //var token =getAuthToken()
    var userGroup_res = {}

    try {
        var userGroupName = userGroupMap.get(&apos;userGroupName&apos;)
        var userGroupType = userGroupMap.get(&apos;userGroupType&apos;)
        var locationName = userGroupMap.get(&apos;locationName&apos;)
        var locIdentifier = userGroupMap.get(&apos;locationIdentifier&apos;)
        if (token) {

            var rolesName = {}
            var orgId = null

            var orgReqParams = new java.util.HashMap()
            orgReqParams.put(&apos;keyName&apos;, &apos;name.value&apos;)
            orgReqParams.put(&apos;keyValue&apos;, configurationMap.get(&apos;organisation&apos;))
            var orgData = findDataFromDB(&apos;ORGANIZATION&apos;, orgReqParams)
            orgId = getId_User(orgData)

            var menuList = getMenuItems_User(userGroupType)
            logger.info(&quot;Menu List :&quot;+JSON.stringify(menuList))
            var patientBannerList = getPatientBannerMenuItems_User(userGroupType,userGroupName)
            logger.info(&quot;PatientBannerList :&quot;+JSON.stringify(patientBannerList))

            if(lookUpEntry){
                var MenuIdlist = []
                for (i in menuList){
                    logger.info(&quot;menuItem to add &quot;+menuList[i].menuItem)
                    MenuIdlist.push(menuList[i].menuItem)
                }
                logger.info(&quot;MenuIdlist : &quot;+MenuIdlist)
                //var flag = 0;
                logger.info(&quot;Inside if : &quot;+JSON.stringify(lookUpEntry.menuItems));
                for(i in lookUpEntry.menuItems){

                    logger.info(&quot;lookUpEntry.menuItemId :&quot;+lookUpEntry.menuItems[i].menuItem)
                    if(MenuIdlist.indexOf(lookUpEntry.menuItems[i].menuItem)== -1 ){
                        menuList.push(lookUpEntry.menuItems[i]);
                        MenuIdlist.push(lookUpEntry.menuItems[i].menuItem)
                    }
                }

                var patientBannerMenuIdList = []//new Packages.java.util.ArrayList()
                for(i in patientBannerList){
                    patientBannerMenuIdList.push(patientBannerList[i].menuItem)
                }
                logger.info(&quot;patientBannerMenuIdList : &quot;+patientBannerMenuIdList)

                for (i in lookUpEntry.patientBannerMenuItems){
                    //logger.info(lookUpEntry.patientBannerMenuItems[i].menuItem)
                    if(patientBannerMenuIdList.indexOf(lookUpEntry.patientBannerMenuItems[i].menuItem )== -1 ){
                        patientBannerList.push(lookUpEntry.patientBannerMenuItems[i]);
                        patientBannerMenuIdList.push(lookUpEntry.patientBannerMenuItems[i].menuItem)
                    }
                }
            }

            logger.info(&quot;Menu List After:&quot;+JSON.stringify(menuList))
            logger.info(&quot;PatientBannerList After:&quot;+JSON.stringify(patientBannerList))

            var userGroupRequestMap = new java.util.HashMap()
            if (orgId &amp;&amp; userGroupName &amp;&amp; menuList &amp;&amp; patientBannerList) {
                logger.info(&quot;[UserGroup] : Going to create User Group with Data&quot;)
                var userGroupSaveUrl = globalMap.get(&quot;minervaUrl&quot;) + JSON.parse(configurationMap.get(&apos;apiInformation&apos;)).userGroupCreate_url


                userGroupRequestMap.put(&quot;userGroupName&quot;, userGroupName)
                userGroupRequestMap.put(&quot;location&quot;, &quot;&quot;)
                userGroupRequestMap.put(&quot;token&quot;, token)
                userGroupRequestMap.put(&quot;menuList&quot;, menuList)
                userGroupRequestMap.put(&quot;orgId&quot;, orgId)
                userGroupRequestMap.put(&quot;patientBannerList&quot;, patientBannerList)
                userGroupRequestMap.put(&quot;token&quot;, token)
                userGroupRequestMap.put(&quot;rolesJson&quot;, rolesName)

                if (userGroupMap.get(&apos;userGroupId&apos;)) {
                var userGroupUpdateUrl = globalMap.get(&quot;minervaUrl&quot;) + JSON.parse(configurationMap.get(&apos;apiInformation&apos;)).userGroupUpdateUrl
                    var userGroupId = userGroupMap.get(&apos;userGroupId&apos;)
                    userGroupRequestMap.put(&quot;userGroupUrl&quot;, userGroupUpdateUrl)
                    userGroupRequestMap.put(&quot;userGroupId&quot;, userGroupId)
                    rolesName = getRoles_User(userGroupType, locationName, locIdentifier, orgId, userGroupId, userGroupName, userGroupMap)
                    if (rolesName) {
                        logger.info(&quot;going to get roles from userGroup&quot;)
                        if(lookUpEntry){
                            for(id in lookUpEntry.authorities){
                                var rolesReqParam = new java.util.HashMap()
                                rolesReqParam.put(&apos;keyName&apos;, &apos;_id&apos;)
                                rolesReqParam.put(&apos;keyValue&apos;, parseInt(id))

                                var rolesData = findDataFromDB(&apos;ROLES&apos;, rolesReqParam)
                                if (rolesData.totalCount &gt; 0) {
                                    logger.info(&quot;[User Group Creation] : Roles Data Count is &quot; + rolesData.totalCount)
                                    var cursor = null
                                    var lookUpEntry1 = null
                                    cursor = rolesData.message
                                    var lookUpEntry1 = JSON.parse(cursor.next())
                                    var roleName = lookUpEntry1.authority
                                    logger.info(&quot;roleName :&quot;+roleName+&quot;test : &quot;+rolesName[roleName])
                                    if(rolesName[roleName]){
                                        /*for(i in lookUpEntry.authorities[id]){
                                        if(rolesName[roleName].indexOf(lookUpEntry.authorities[id][i])==-1)
                                        rolesName[roleName].push(lookUpEntry.authorities[id][i])
                                        }*/
                                    }else{
                                        rolesName[roleName]=lookUpEntry.authorities[id]
                                    }
                                }
                            }

                        }

                        userGroupRequestMap.put(&quot;rolesJson&quot;, rolesName)
                        logger.info(&quot;Roles Name:&quot;+JSON.stringify(rolesName))
                    } else {
                        FileUtil.write(&apos;/tmp/log.txt&apos;, true, channelName + &quot;:&quot; + &quot;[User Group] : Role is not Found for userGroup Id &quot; + userGroupId + &quot;\n&quot;);
                    }
                } else {
                    userGroupRequestMap.put(&quot;userGroupUrl&quot;, userGroupSaveUrl)
                }
                userGroup_res = createAndUpdateUserGroup(userGroupRequestMap)

                if (userGroup_res.status == 200) {
                    logger.info([&quot;User Group Created Successfully&quot;])
                }
            } else {
                FileUtil.write(&apos;/tmp/log.txt&apos;, true, channelName + &quot;:&quot; + &quot;[User Group] : Some Fields are missing for creating user group&quot; + &quot;\n&quot;);
                //logger.error(&quot;[User Group] : Some Fields are missing for creating user group &quot;)
            }
        } else {
            // logger.error(&quot;[User Group Creation ] createUserGroupvViaCSV_User : Error occured while getting token from login API&quot;)
            FileUtil.write(&apos;/tmp/log.txt&apos;, true, channelName + &quot;:&quot; + &quot;[User Group Creation ] createUserGroupvViaCSV_User : Error occured while getting token from login API in CreateuserGroup&quot;);
        }
    } catch (e) {
        logger.error(&quot;Exception Occured while creating user/userGroup&quot;+e + e.stack)
        throw(e)
    }

    return userGroup_res
}

function getRoles_User(userGroupType, locationName, locationIdentifier, orgId, userGroupId, userGroupName, userGroupDataMap) {
    logger.info(&quot;Test4 : &quot;+userGroupDataMap)
    logger.info(&quot;[User Group Creation] : Inside Get Roles Function &quot;)

    try {
        var rolesName = {}
        var userGroupMap = JSON.parse(configurationMap.get(&apos;userGroupCreationMap&apos;))
        var roleLocatioIdList = new java.util.ArrayList()


        if (userGroupType in userGroupMap) {
            logger.info(&quot;[User Group] Going to get Roles Data for Team ==&quot; + JSON.stringify(userGroupMap[userGroupType]))
            for (rolesArray in userGroupMap[userGroupType].roles) {
                logger.info(&apos;Roles Team is :&apos;+userGroupMap[userGroupType].roles[rolesArray])
                var cursor = null
                var lookUpEntry = null
                var rolesReqParam = new java.util.HashMap()
                rolesReqParam.put(&apos;keyName&apos;, &apos;authority&apos;)
                rolesReqParam.put(&apos;keyValue&apos;, userGroupMap[userGroupType].roles[rolesArray])

                var rolesData = findDataFromDB(&apos;ROLES&apos;, rolesReqParam)

                if (rolesData.totalCount &gt; 0) {
                    logger.info(&quot;[User Group Creation] : Roles Data Count is &quot; + rolesData.totalCount)
                    cursor = rolesData.message
                    lookUpEntry = JSON.parse(cursor.next())
                    var userGroupIdList = new java.util.ArrayList()
                    if (userGroupMap[userGroupType].roles[rolesArray] == &quot;ROLE_LOCATION_ACCESS&quot;) {

                        if (locationName &amp;&amp; locationIdentifier) {
                        	   var facilityAddressMap = {}
                        	   facilityAddressMap.facilityAddress = userGroupDataMap.get(&quot;facilityAddress&quot;);
                            facilityAddressMap.facilityCity = userGroupDataMap.get(&quot;facilityCity&quot;);
                            facilityAddressMap.facilityState = userGroupDataMap.get(&quot;facilityState&quot;);
                            facilityAddressMap.facilityPostalCode = userGroupDataMap.get(&quot;facilityPostalCode&quot;);
                            var locDataMap = getLocationData(locationName, locationIdentifier, orgId, facilityAddressMap, true)
                            logger.info(&quot;FROM getLocationData : &quot;+JSON.stringify(locDataMap))
                            if(locDataMap.status==&quot;FAILED&quot;){
                                throw(locDataMap.errMessage);
                            }else{
                                roleLocatioIdList.add(locDataMap.locationId)
                            }
                        }
                        rolesName[lookUpEntry.authority] = roleLocatioIdList
                    }else if(userGroupMap[userGroupType].roles[rolesArray] == &quot;ROLE_DELETE_FORM&quot;){
					rolesName[lookUpEntry.authority] = []
				}else {
                        	rolesName[lookUpEntry.authority] = &quot;&quot;
                    }
                    if (userGroupMap[userGroupType].roles[rolesArray] == &quot;ROLE_TASK_ACCESS&quot;) {
                        //userGroupIdList.add(userGroupId)
                        //rolesName[lookUpEntry.authority] = userGroupIdList
                        logger.info(&quot;Role Task Access Data&quot; + lookUpEntry._id)
                        var userGroupParam = {}
                        userGroupParam[&apos;authorities&apos;+&apos;.&apos;+lookUpEntry._id] = {&quot;$exists&quot;:true};
                        userGroupParam[&quot;_id&quot;] = userGroupId;

                        var auscUserGroupData = findDataFromDB(&apos;USERGROUP&apos;,userGroupParam)
                        logger.info(&quot;auscUserGroupData:&quot;+JSON.stringify(auscUserGroupData))

                        //logger.info(list)
                        if (auscUserGroupData.totalCount &gt; 0) {
                            var cursor2 = auscUserGroupData.message
                            logger.info(&quot;cursor2 &quot; + JSON.stringify(cursor2))
                            var lookUpEntry1 = JSON.parse(cursor2.next())
                            logger.info(&quot;lookUpEntry1&quot; + JSON.stringify(lookUpEntry1))
                            logger.info( &quot;Task Value:&quot;+lookUpEntry1.authorities[lookUpEntry._id.toString()])
                            logger.info(&quot;Task Exists in Db&quot;)
                            logger.info(&quot;ROLE_TASK_ACCESS_ALREADY_EXISTS_IN_USERGROUP : &quot;+userGroupId);
                            userGroupIdList.add(userGroupId)
                            logger.info(&quot;Got authority &quot;+lookUpEntry._id.toString()+&quot; as :&quot;+JSON.stringify(lookUpEntry1.authorities[lookUpEntry._id.toString()]))
                            //userGroupIdList.add(lookUpEntry1.authorities[lookUpEntry._id.toString()])
                            for(i in lookUpEntry1.authorities[lookUpEntry._id.toString()]){
                                if(userGroupIdList.indexOf(lookUpEntry1.authorities[lookUpEntry._id.toString()][i])== -1){
                                    userGroupIdList.add(lookUpEntry1.authorities[lookUpEntry._id.toString()][i])
                                }
                            }
                            //var set = new Set(userGroupIdList);
                            //userGroupIdList = Array.from(set)
                            logger.info(&quot;userGroupIdList&quot;+JSON.stringify(userGroupIdList))
                            rolesName[lookUpEntry.authority] = userGroupIdList

                        }else{
                            logger.info(&quot;Task Access Not exist in userGroup&quot;)
                            userGroupIdList.add(userGroupId)
                            rolesName[lookUpEntry.authority] = userGroupIdList
                        }

                    }
                }
            }
            if(userGroupMap[userGroupType].formRoles &amp;&amp; (userGroupName != &quot;LHH Operating Room&quot; &amp;&amp; userGroupName != &quot;LHH PAT&quot; &amp;&amp; userGroupName != &quot;LHH Booking&quot;)){
                for(rolesArray in userGroupMap[userGroupType].formRoles){
                    logger.info(&apos;Form Roles Team is :&apos;+userGroupMap[userGroupType].formRoles[rolesArray])
                    var cursor = null
                    var lookUpEntry = null
                    var rolesReqParam = new java.util.HashMap()
                    rolesReqParam.put(&apos;keyName&apos;, &apos;authority&apos;)
                    rolesReqParam.put(&apos;keyValue&apos;, rolesArray)

                    var rolesData = findDataFromDB(&apos;ROLES&apos;, rolesReqParam)

                    if (rolesData.totalCount &gt; 0) {
                        logger.info(&quot;[User Group Creation] : Roles Data Count is &quot; + rolesData.totalCount)
                        cursor = rolesData.message
                        lookUpEntry = JSON.parse(cursor.next())
                        rolesName[lookUpEntry.authority] = userGroupMap[userGroupType].formRoles[rolesArray]
                    }
                }
            }
        } else {
            FileUtil.write(&apos;/tmp/log.txt&apos;, true, channelName + &quot;: &quot; + &quot;[User Group Creation]  getRoles_User: userGroupType Key doesnot exist in Json&quot; + userGroupType + &quot;\n&quot;);
            // logger.error(&quot;[User Group Creation] getRoles_User: userGroupType Key doesnot exist in Json&quot;)
        }


        return rolesName;
    } catch (e) {
        logger.error(&apos;Exception occured while getting roles&apos;+e + e.stack)
        throw(e)
    }


}


function getMenuItems_User(userGroupType) {
    logger.info(&quot;[User Group Creation ] : Inside getMenuItems_User with userGroupType&quot; + userGroupType)
    var menuList = []//new Packages.java.util.ArrayList()
    try {
        var menuJson = JSON.parse(configurationMap.get(&apos;userGroupCreationMap&apos;))

        if (userGroupType in menuJson) {
            for (menu in menuJson[userGroupType].menuItems) {
                logger.info(&quot;[UserGroup]: User Group Menu Data Inside Loop &quot; + menuJson[userGroupType].menuItems[menu])
                var menuItemReqParam = new java.util.HashMap()
                menuItemReqParam.put(&apos;keyName&apos;, &apos;name&apos;)
                menuItemReqParam.put(&apos;keyValue&apos;, menuJson[userGroupType].menuItems[menu])

                var menuData = findDataFromDB(&apos;MENUITEM&apos;, menuItemReqParam)
                logger.info(&quot;[User Group Creation] : Menu Items Count is &quot; + menuData.totalCount)
                if (menuData.totalCount &gt; 0) {

                    var menusId = {}
                    var menuId = getId_User(menuData)
                    menusId.menuItem = menuId

                    if (menuJson[userGroupType].menuItems[menu] == menuJson[userGroupType].defaultMenuBar) {

                        menusId.isDefault = true
                    } else {
                        menusId.isDefault = false
                    }

                    menuList.push(menusId)
                    logger.info(&quot;[User  Group Creation] :  Menu List Created is &quot; + JSON.stringify(menuList))
                }
            }

        } else {
            FileUtil.write(&apos;/tmp/log.txt&apos;, true, channelName + &quot;: &quot; + &quot;[User Group Creation] getMenuItems_User: userGroupType Key doesnot exist in Json&quot; + userGroupType + &quot;\n&quot;);
            // logger.error(&quot;[User Group Creation] getMenuItems_User: userGroupType Key doesnot exist in Json&quot;)
        }
    } catch (e) {
        logger.error(&quot;Exception occured while getting menu items&quot;+e + e.stack)
    }


    return menuList;

}


function getPatientBannerMenuItems_User(userGroupType,userGroupName) {
    logger.info(&quot;[User Group Creation] :  Inside getPatientBannerMenuItems_User for userGroupType&quot; + userGroupType)
    var patientBannerList = []// new Packages.java.util.ArrayList()

    try {
        var patientBannerMenuJson = JSON.parse(configurationMap.get(&apos;userGroupCreationMap&apos;))

        if (userGroupType in patientBannerMenuJson) {
            for (patientMenu in patientBannerMenuJson[userGroupType].patientBanner) {
                logger.info(&quot;[UserGroup]: User Group patient Banner Menu Data Inside Loop &quot; + patientBannerMenuJson[userGroupType].patientBanner[patientMenu])
                if(patientBannerMenuJson[userGroupType].patientBanner[patientMenu]== &quot;eforms&quot; &amp;&amp; (userGroupName == &quot;LHH Operating Room&quot; || userGroupName == &quot;LHH PAT&quot; || userGroupName == &quot;LHH Booking&quot;)){
                    continue;
                }
                var menuItemReqParam = new java.util.HashMap()
                menuItemReqParam.put(&apos;keyName&apos;, &apos;name&apos;)
                menuItemReqParam.put(&apos;keyValue&apos;, patientBannerMenuJson[userGroupType].patientBanner[patientMenu])

                var patientMenuData = findDataFromDB(&apos;MENUITEM&apos;, menuItemReqParam)
                logger.info(&quot;Patient Banner Menu Data is &quot; + patientMenuData)
                if (patientMenuData.totalCount &gt; 0) {
                    logger.info(&quot;[User Group] :Inside Search Data count for patient Banner menuItems&quot;)
                    var patientBanner = {}
                    var patientMenuId = getId_User(patientMenuData)
                    patientBanner.menuItem = patientMenuId
                    if (patientBannerMenuJson[userGroupType].patientBanner[patientMenu] == patientBannerMenuJson[userGroupType].defaultPatientBanner) {
                        patientBanner.isDefault = true
                    } else {
                        patientBanner.isDefault = false
                    }

                    patientBannerList.push(patientBanner)

                    logger.info(&quot;===========Patient Banner List&quot; + JSON.stringify(patientBannerList))

                } else {
                    logger.error(&quot;PatientMenuData Not Found&quot;)
                }
            }
        } else {
            FileUtil.write(&apos;/tmp/log.txt&apos;, true, channelName + &quot;: &quot; + &quot;[User Group Creation] getPatientBannerMenuItems_User : userGroupType Key doesnot exist in Json&quot; + userGroupType + &quot;\n&quot;);
            //	logger.error(&quot;[User Group Creation] getPatientBannerMenuItems_User:  userGroupType doesnot exist in Json&quot;)

        }

    } catch (e) {
        logger.error(&quot;Exception Occured while getting patient banner Items&quot;+e + e.stack)
    }
    return patientBannerList;

}

function updateUserGroupRoles_User(requestMap) {
                logger.info(&quot;Going to Update UserGroup &quot; + accessRole)
    var userGroup_res = null
                try {
                var userGroupUpdateUrl = globalMap.get(&quot;minervaUrl&quot;) + JSON.parse(configurationMap.get(&apos;apiInformation&apos;)).userGroupUpdateUrl

        var userGroupData = requestMap.get(&apos;userGroupData&apos;)
        //  var token = getAuthToken()
        var token = configurationMap.get(&apos;xAuthToken&apos;)
        logger.info(&quot;rolesReq&quot; + JSON.stringify(lookUpEntry.authorities))

        var userUpdateRequestMap = new java.util.HashMap()
        userUpdateRequestMap.put(&quot;orgId&quot;, userGroupData.organizationId)
        userUpdateRequestMap.put(&quot;userGroupName&quot;, userGroupData.name)
        userUpdateRequestMap.put(&quot;location&quot;, userGroupData.locationId)
        userUpdateRequestMap.put(&quot;rolesJson&quot;, requestMap.get(&apos;roles&apos;))
        userUpdateRequestMap.put(&quot;menuList&quot;, userGroupData.menuItems)
        userUpdateRequestMap.put(&quot;patientBannerList&quot;, userGroupData.patientBannerMenuItems)
        userUpdateRequestMap.put(&quot;token&quot;, requestMap.get(&apos;token&apos;))
        userUpdateRequestMap.put(&quot;userGroupUrl&quot;, userGroupUpdateUrl)
        userUpdateRequestMap.put(&quot;userGroupId&quot;, userGroupData._id)
        userGroup_res = createAndUpdateUserGroup(userUpdateRequestMap)

        logger.info(&quot;Result =======&quot; + userGroup_res)

        if (userGroup_res.status == 200) {
            logger.info([&quot;User Group Updated Successfully&quot;])
        } else {
            FileUtil.write(&apos;/tmp/log.txt&apos;, true, channelName + &quot;:&quot; + &quot;Error occured while updating userGroup Task role for userGroup Id&quot; + lookUpEntry._id + &quot;\n&quot;);
            //logger.error(&quot;[User Group] : Some Fields are missing for creating user group &quot;)
        }

    } catch (e) {
        logger.error(&quot;Exception Occured while updating user Group Roles&quot;+e + e.stack)
    }

    return userGroup_res
}

function getId_User(jsonData) {
    try {
        logger.info(&quot;Inside getId_User function with json Response =======&quot; + jsonData)
        var cursor = jsonData.message
        var lookUpEntry = JSON.parse(cursor.next())

        return lookUpEntry._id
    } catch (e) {
        logger.error(&quot;Exception Occured while Getting id&quot;+e + e.stack)
    }
}

function validateData_User(requestMap) {
    var filter = {
        &quot;flag&quot;: true,
        &quot;errorMsg&quot;: &quot;&quot;
    }
    var error = &quot;&quot;
    try {
        /*if((!requestMap.get(&apos;firstName&apos;) == null || (requestMap.get(&apos;firstName&apos;) &amp;&amp;  !(requestMap.get(&apos;firstName&apos;).match(/[a-zA-Z]/)))) || (!requestMap.get(&apos;lastName&apos;)|| (requestMap.get(&apos;lastName&apos;) &amp;&amp;  !(requestMap.get(&apos;lastName&apos;).match(/[a-zA-Z]/))) )){
        error=&quot;Either  Name is Missing or invalid&quot;
        }*/

        if(!requestMap.get(&apos;locationIdentifier&apos;) || requestMap.get(&apos;locationIdentifier&apos;) == &quot;&quot;){
            error=error + &quot; | LOCATION_ID_IS_INVALID&quot;
        }

        if(requestMap.get(&apos;locationName&apos;) &amp;&amp; requestMap.get(&apos;locationName&apos;).indexOf(&quot;\&apos;&quot;) != -1){
        	error = error + &quot;| INVALID_LOCATION_NAME_CONTAINS_CHARACTER/s(&apos;)&quot;
		}

        if(requestMap.get(&apos;locationIdentifier&apos;)){
            var locationFindMap = new java.util.HashMap()
            locationFindMap.put(&quot;keyName&quot;,&apos;identifier.value.value&apos;)
            logger.info(&quot;locationIdentifier found : &quot;+requestMap.get(&apos;locationIdentifier&apos;))
            locationFindMap.put(&quot;keyValue&quot;,requestMap.get(&apos;locationIdentifier&apos;).toString())
            var locationData= findDataFromDB(&apos;LOCATION&apos;,locationFindMap)
            logger.info(&quot;Total Location Count : &quot;+locationData.totalCount)
            if(locationData.totalCount &gt; 0){
                var cursor =locationData.message
                var lookUpEntry=JSON.parse(cursor.next())
                if(lookUpEntry.status &amp;&amp; lookUpEntry.status.value != &quot;active&quot;)
                    error = error + &quot; | THE LOCATION &quot;+requestMap.get(&apos;locationIdentifier&apos;)+&quot; IS DISABLED. ENABLE IT TO PROCESS THE USER&quot;
            }
        }

        if (!requestMap.get(&apos;email&apos;) || (requestMap.get(&apos;email&apos;) &amp;&amp; !(requestMap.get(&apos;email&apos;).match(/^[\w\.\-]+([\w\.\-]+)*\@[\w\.\-]+\.[\w]{2,}$/)))) {
            //	filter.flag=false
            error = error + &quot; | &quot;+(requestMap.get(&apos;email&apos;) ? &quot;EMAIL_IS_INVALID : CHAR_SET_OUT_OF [a-zA-Z0-9@._-]&quot; : &quot;EMAIL_IS_EMPTY&quot;);
        }

        if (!requestMap.get(&apos;userGroupName&apos;) ) {

            error =  error + &quot; | USER_GROUP_NAME_IS_EMPTY&quot;;
        }

        if(requestMap.get(&apos;userGroupName&apos;) &amp;&amp; requestMap.get(&apos;userGroupName&apos;).indexOf(&quot;\&apos;&quot;) != -1){
        	error =  error + &quot; | INVALID_USER_GROUP_NAME_CONTAINS_CHARACTER/s(&apos;)&quot;;
        }

        if (!requestMap.get(&apos;userType&apos;) || (requestMap.get(&apos;userType&apos;) &amp;&amp; !(requestMap.get(&apos;userType&apos;).match(/^[a-zA-Z]+$/)))) {
            error = error + &quot; | &quot;+(requestMap.get(&apos;userType&apos;) ? &quot;USER_TYPE_IS_INVALID : CHAR_SET_OUT_OF [a-zA-Z]&quot; : &quot;USER_TYPE_IS_EMPTY&quot;)
        }

        if (error || error != &quot;&quot;) {
            filter.flag = false
            filter.errorMsg = error
        }
    } catch (e) {
        logger.error(&quot;Exception Occured while filtering CSV Data : &quot;+e +e.stack )
        filter.flag = false
        filter.errorMsg = &quot;ERROR_IN_PARSING_MESSAGE&quot;
    }
    return filter;
}

function closeMatchCheck_User(firstName, lastName) {

    var returnMap = {&quot;errMessage&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;}
    var userFindMap = {}

    if(firstName.length()&gt;=4){
        firstName = firstName.substring(0,4).toString()
    }
    if(lastName.length() &gt;= 4){
        lastName = lastName.substring(lastName.length() -4,lastName.length()).toString()
    }

    userFindMap[&quot;firstName&quot;] = {&quot;$regex&quot;:(&quot;^&quot;+firstName).toString(),&quot;$options&quot;:&quot;i&quot;}
    userFindMap[&quot;lastName&quot;] = {&quot;$regex&quot;:(lastName+&quot;$&quot;).toString(), &quot;$options&quot; : &quot;i&quot;}
    try{
        var  userResource = findDataFromDB(&apos;USER&apos;,userFindMap,&quot;AND&quot;)
        if(userResource.totalCount  &amp;&amp; userResource.totalCount &gt; 0){
            logger.info(&quot;FOUND_MULTIPLE_USER_WITH_SIMILAR_NAME&quot;+userResource)
            returnMap = {&quot;errMessage&quot;:&quot;FOUND_MULTIPLE_USER_WITH_SIMILAR_NAME&quot;,&quot;status&quot;:&quot;FAILED&quot;}
        }
    }
    catch(ex){
        logger.error(&quot;EXCEPTION_WHILE_FETCHING_CLOSE_MATCH_OF_USER&quot;+ex + ex.stack)
        returnMap = {&quot;errMessage&quot;:&quot;EXCEPTION_WHILE_FETCHING_CLOSE_MATCH_OF_USER&quot;,&quot;status&quot;:&quot;FAILED&quot;}
    }

    return returnMap
}</code>
      </properties>
    </codeTemplate>
      <codeTemplate version="3.5.0">
          <id>a32595d7-0abc-4152-ab82-7512f0374f4a</id>
          <name>enableJob</name>
          <revision>8</revision>
          <lastModified>
              <time>1609318642046</time>
              <timezone>America/New_York</timezone>
          </lastModified>
          <contextSet>
              <delegate>
                  <contextType>SOURCE_RECEIVER</contextType>
                  <contextType>GLOBAL_PREPROCESSOR</contextType>
                  <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                  <contextType>CHANNEL_ATTACHMENT</contextType>
                  <contextType>CHANNEL_BATCH</contextType>
                  <contextType>GLOBAL_DEPLOY</contextType>
                  <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                  <contextType>CHANNEL_DEPLOY</contextType>
                  <contextType>GLOBAL_UNDEPLOY</contextType>
                  <contextType>DESTINATION_DISPATCHER</contextType>
                  <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                  <contextType>CHANNEL_PREPROCESSOR</contextType>
                  <contextType>GLOBAL_POSTPROCESSOR</contextType>
                  <contextType>CHANNEL_POSTPROCESSOR</contextType>
                  <contextType>CHANNEL_UNDEPLOY</contextType>
              </delegate>
          </contextSet>
          <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
                  Modify the description here. Modify the function name and parameters as needed. One function per
                  template is recommended; create a new code template for each new function.

                  @param {Any} serviceName -
                  @return {String} return description
                  */
                  function enableJob(serviceName) {
                  try{
                  var jobMap = {}
                  jobMap.collectionName = &quot;jobConfiguration&quot;
                  jobMap.document = new Packages.com.mongodb.BasicDBObject(&quot;enabled&quot;,true)
                  jobMap.find = new Packages.com.mongodb.BasicDBObject(&quot;serviceName&quot;,new Packages.com.mongodb.BasicDBObject(&quot;\$in&quot;,serviceName))
                  jobMap.multi = true
                  var jobUpdateRes = MongoGlobalService(&quot;update&quot;, jobMap)
                  logger.info(&quot;Job enabled sucessfully &quot;+jobUpdateRes)
                  }catch(ex){
                  logger.error(ex);
                  }
                  }</code>
          </properties>
      </codeTemplate>
    <codeTemplate version="3.5.0">
      <id>56fac295-d2ad-4ec6-9494-9138d5a6e4b2</id>
      <name>findDataFromDB</name>
      <revision>8</revision>
      <lastModified>
        <time>1600249966894</time>
        <timezone>America/New_York</timezone>
      </lastModified>
      <contextSet>
        <delegate>
          <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
          <contextType>DESTINATION_DISPATCHER</contextType>
          <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
          <contextType>SOURCE_RECEIVER</contextType>
          <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
        </delegate>
      </contextSet>
      <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
        <type>FUNCTION</type>
        <code>/**
                                Modify the description here. Modify the function name and parameters as needed. One function per
                                template is recommended; create a new code template for each new function.

                                @param {String} arg1 - arg1 description
                                @return {String} return description
                                */
                                function findDataFromDB(action,requestMap,groupBy) {
                                // TODO: Enter code here

                                var result = null
                                if(action == &quot;PRACTITIONER&quot;){
                                return result = findPractitioner(requestMap,groupBy)
                                }

                                if(action == &quot;LOCATION&quot;){
                                return result = findLocation(requestMap)
                                }

                                if(action == &quot;USER&quot;){
                                return result = findUser(requestMap,groupBy)
                                }

                                if(action == &quot;USERGROUP&quot;){
                                return result = findUserGroup(requestMap,groupBy)
                                }

                                if(action == &quot;ORGANIZATION&quot;){
                                return result = findOrganization(requestMap)
                                }
                                if(action == &quot;ROLES&quot;){
                                return result = findRoles(requestMap)
                                }

                                if(action==&quot;MENUITEM&quot;){
                                return result = findMenuItem(requestMap)
                                }

                                if(action == &quot;COUNTRIESSET&quot;){
							return result = findCountriesSet(requestMap,groupBy)
							}
							
							if(action == &quot;CITIESSET&quot;){
							return result = findCitiesSet(requestMap,groupBy)
							}
							
							if(action == &quot;STATESSET&quot;){
							return result = findStatesSet(requestMap,groupBy)
							}
                                }

                                function findLocation(requestMap){&#xd;  	  					logger.info(&quot;Inside Find Location function With &quot; + requestMap.get(&apos;keyName&apos;) + requestMap.get(&apos;keyValue&apos;) )
                                var locationData=null
                                var queryMap ={}
                                if(JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).locationCollectionName){
                                   var locationQuery= new Packages.com.mongodb.BasicDBObject(requestMap.get(&apos;keyName&apos;), requestMap.get(&apos;keyValue&apos;))
                                	queryMap.collectionName = JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).locationCollectionName
                                	queryMap.find = locationQuery
                                	locationData =MongoGlobalService(&quot;search&quot;,queryMap)
                                }else{
                                	logger.error(&quot;Location Collection name is not defined in configurationMap&quot;)
                                }

                                return locationData;
                                }

                                function findUserGroup(requestMap,groupBy){
                                logger.info(&quot;Inside findUsergroup Function&quot; + requestMap)
                                var userGroupSearchResponse=null
                                var queryMap ={}
                                if(JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).userGroupCollectionName){
                                var searchList = new Packages.java.util.ArrayList();
                                for (key in requestMap){
                                //logger.info(&quot;Iteration of searchMap : &quot;+key+&quot; : &quot;+requestMap[key])
                                searchList.add(new Packages.com.mongodb.BasicDBObject(key, requestMap[key]));
                                }
                                queryMap.collectionName=JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).userGroupCollectionName;
                                if(groupBy == &quot;OR&quot;){
                                queryMap.find = new Packages.com.mongodb.BasicDBObject(&apos;$or&apos;, searchList);
                                }else{
                                queryMap.find = new Packages.com.mongodb.BasicDBObject(&apos;$and&apos;, searchList);

                                }
                                userGroupCollectionName =  MongoGlobalService(&quot;search&quot;,queryMap)
                                }else{
                                logger.error(&quot;userGroup Collection Name is not defined in configurationMap&quot;)
                                }
                                return userGroupCollectionName;
                                }



                                function findUser(requestMap,groupBy){
                                logger.info(&quot;Inside Search User Function&quot; + requestMap)
                                var userSearch_res=null
                                var queryMap ={}
                                if(JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).userCollectionName){
                                var searchList = new Packages.java.util.ArrayList();
                                for (key in requestMap){
                                //logger.info(&quot;Iteration of searchMap : &quot;+key+&quot; : &quot;+requestMap[key])
                                searchList.add(new Packages.com.mongodb.BasicDBObject(key, requestMap[key]));
                                }
                                queryMap.collectionName=JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).userCollectionName;
                                if(groupBy == &quot;OR&quot;){
                                queryMap.find = new Packages.com.mongodb.BasicDBObject(&apos;$or&apos;, searchList);
                                }else{
                                queryMap.find = new Packages.com.mongodb.BasicDBObject(&apos;$and&apos;, searchList);

                                }
                                userSearch_res =  MongoGlobalService(&quot;search&quot;,queryMap)
                                }else{
                                logger.error(&quot;User Collection Name is not defined in configurationMap&quot;)
                                }
                                return userSearch_res;
                                }

                                function findPractitioner(requestMap,groupBy){
                                logger.info(&quot;Inside Find Practitioner&quot;)
                                var practitionerSearchData=null
                                var queryMap= {}
                                if(JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).practitionerCollectionName){
                                var searchList = new Packages.java.util.ArrayList();
                                for (key in requestMap){
                                //logger.info(&quot;Iteration of searchMap : &quot;+key+&quot; : &quot;+requestMap[key])
                                searchList.add(new Packages.com.mongodb.BasicDBObject(key, requestMap[key]));
                                }
                                queryMap.collectionName=JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).practitionerCollectionName;
                                if(groupBy == &quot;OR&quot;){
                                queryMap.find = new Packages.com.mongodb.BasicDBObject(&apos;$or&apos;, searchList);
                                }else{
                                queryMap.find = new Packages.com.mongodb.BasicDBObject(&apos;$and&apos;, searchList);

                                }

                                //logger.info(&quot;FINDQUERY : &quot;+queryMap.find)
                                practitionerSearchData  =  MongoGlobalService(&quot;search&quot;,queryMap)
                                }else{
                                logger.error(&quot;Practitioner collection Name is not defined in configurationMap&quot;)
                                }

                                return practitionerSearchData;

                                }


                                function findOrganization(requestMap){
                                logger.info(&quot;[Find Organization ] :  Inside getOrganization Function &quot; +requestMap.get(&apos;keyName&apos;))
                                var organizationData=null
                                var queryMap = {}
                                if(JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).orgCollectionName){
                                var organizationQuery=new Packages.com.mongodb.BasicDBObject(requestMap.get(&apos;keyName&apos;),requestMap.get(&apos;keyValue&apos;))
                                queryMap.collectionName = JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).orgCollectionName;
                                queryMap.find=  organizationQuery
                                organizationData= MongoGlobalService(&quot;search&quot;,queryMap)

                                }else{
                                logger.error(&quot;Organization collectionName is not defined in configurationMap&quot;)
                                }
                                return organizationData;&#xd;
                                }

                                function findRoles(requestMap){
                                logger.info(&quot;[Find Roles ] :  Inside findRoles Function &quot;)
                                var rolesData=null
                                var queryMap = {}
                                if(JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).roleCollectionName){
                                var rolesQuery = new Packages.com.mongodb.BasicDBObject(requestMap.get(&apos;keyName&apos;),requestMap.get(&apos;keyValue&apos;))
                                queryMap.collectionName = JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).roleCollectionName;
                                queryMap.find=  rolesQuery
                                rolesData= MongoGlobalService(&quot;search&quot;,queryMap)

                                }else{
                                logger.error(&quot;Roles collectionName is not defined in configurationMap&quot;)
                                }
                                return rolesData
                                }


                                function findMenuItem(requestMap){
                                logger.info(&quot;[Find Roles ] :  Inside findMenuItem Function &quot;)
                                var menuData=null
                                var queryMap={}
                                if(JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).menuCollectionName){
                                var menuQuery = new Packages.com.mongodb.BasicDBObject(requestMap.get(&apos;keyName&apos;),requestMap.get(&apos;keyValue&apos;))
                                queryMap.collectionName = JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).menuCollectionName;
                                queryMap.find=  menuQuery
                                menuData= MongoGlobalService(&quot;search&quot;, queryMap)
                                }else{
                                logger.error(&quot;menuItem collectionName is not defined in configurationMap&quot;)
                                }
                                return menuData
                                }

                                /*
                                function searchDataFromCollection(queryMap,collectionName) {
                                // TODO: Enter code here
                                logger.info(&quot;[User Group] : Inside Search Function &quot;)
                                logger.info(&quot;Query Object is &quot;+queryMap)
                                var requestMap={};
                                requestMap.collectionName=collectionName;
                                requestMap.find=new Packages.com.mongodb.BasicDBObject(queryMap);
                                logger.info(&quot;Search Map Created : &quot;+ requestMap);
                                var searchResponse=MongoGlobalService(&quot;search&quot;,requestMap);
                                logger.info(&quot;Search Map Cursor is :&quot;+ JSON.stringify(searchResponse));
                                logger.info(&quot;Count for this query is :&quot;+ searchResponse.totalCount)
                                logger.info(&quot;Search Map response  is : &quot;+ searchResponse.success);
                                return searchResponse;

                                }*/

                                								function findCitiesSet(requestMap,groupBy){
                                logger.info(&quot;[Find CitesSet ] :  Inside findCitesSet Function &quot;)
                                var citiesSetData=null
                                var queryMap={}
                                if(JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).citiesSetCollectionName){
                                var searchList = new Packages.java.util.ArrayList();
                                for (key in requestMap){
                                //logger.info(&quot;Iteration of searchMap : &quot;+key+&quot; : &quot;+requestMap[key])
                                searchList.add(new Packages.com.mongodb.BasicDBObject(key, requestMap[key]));
                                }
                                queryMap.collectionName = JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).citiesSetCollectionName;
								
								if(groupBy == &quot;OR&quot;){
                                queryMap.find = new Packages.com.mongodb.BasicDBObject(&apos;$or&apos;, searchList);
                                }else{
                                queryMap.find = new Packages.com.mongodb.BasicDBObject(&apos;$and&apos;, searchList);
                                }
                                citiesSetData= MongoGlobalService(&quot;search&quot;, queryMap)
                                }else{
                                logger.error(&quot;CitesSet collectionName is not defined in configurationMap&quot;)
                                }
                                return citiesSetData
                                }
								
								function findCountriesSet(requestMap,groupBy){
                                logger.info(&quot;[Find CountriesSet ] :  Inside findCountriesSet Function &quot;)
                                var countriesSetData=null
                                var queryMap={}
                                if(JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).countriesSetCollectionName){
                                var searchList = new Packages.java.util.ArrayList();
                                for (key in requestMap){
                                //logger.info(&quot;Iteration of searchMap : &quot;+key+&quot; : &quot;+requestMap[key])
                                searchList.add(new Packages.com.mongodb.BasicDBObject(key, requestMap[key]));
                                }
                                queryMap.collectionName = JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).countriesSetCollectionName;
								
								if(groupBy == &quot;OR&quot;){
                                queryMap.find = new Packages.com.mongodb.BasicDBObject(&apos;$or&apos;, searchList);
                                }else{
                                queryMap.find = new Packages.com.mongodb.BasicDBObject(&apos;$and&apos;, searchList);
                                }
                                countriesSetData= MongoGlobalService(&quot;search&quot;, queryMap)
                                }else{
                                logger.error(&quot;CountriesSet collectionName is not defined in configurationMap&quot;)
                                }
                                return countriesSetData
                                }
								
								function findStatesSet(requestMap,groupBy){
                                logger.info(&quot;[Find StatesSet ] :  Inside FindStatesSet Function &quot;)
                                var statesSetData=null
                                var queryMap={}
                                if(JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).statesSetCollectionName){
                                var searchList = new Packages.java.util.ArrayList();
                                for (key in requestMap){
                                //logger.info(&quot;Iteration of searchMap : &quot;+key+&quot; : &quot;+requestMap[key])
                                searchList.add(new Packages.com.mongodb.BasicDBObject(key, requestMap[key]));
                                }
                                queryMap.collectionName = JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).statesSetCollectionName;
								
								if(groupBy == &quot;OR&quot;){
                                queryMap.find = new Packages.com.mongodb.BasicDBObject(&apos;$or&apos;, searchList);
                                }else{
                                queryMap.find = new Packages.com.mongodb.BasicDBObject(&apos;$and&apos;, searchList);
                                }
                                statesSetData= MongoGlobalService(&quot;search&quot;, queryMap)
                                }else{
                                logger.error(&quot;StatesSet collectionName is not defined in configurationMap&quot;)
                                }
                                return statesSetData
                                }
                            
                            </code>
      </properties>
    </codeTemplate>
    <codeTemplate version="3.5.0">
      <id>3ad6edb9-3bb1-4f92-ad5c-e421f56c9576</id>
      <name>GenerateUserNameAndPassword</name>
      <revision>1</revision>
      <lastModified>
        <time>1597059086169</time>
        <timezone>America/New_York</timezone>
      </lastModified>
      <contextSet>
        <delegate>
          <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
          <contextType>DESTINATION_DISPATCHER</contextType>
          <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
          <contextType>SOURCE_RECEIVER</contextType>
          <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
        </delegate>
      </contextSet>
      <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
        <type>FUNCTION</type>
        <code>/**
                                Modify the description here. Modify the function name and parameters as needed. One function per
                                template is recommended; create a new code template for each new function.

                                @param {String} arg1 - arg1 description
                                @return {String} return description
                                */
                                function GenerateUserNameAndPassword(userMap) {
                                logger.debug(&quot;[Generate Random user Name Password] : Inside GenerateUserNameAndPassword with Params&quot; +  + userMap.get(&apos;firstname&apos;) + &quot; &quot; + userMap.get(&apos;email&apos;))
                                // TODO: Enter code here
                                var userNameAndPassword = {}
                                try {
                                var requestMap = {}
                                requestMap.collectionName = &apos;counters&apos;
                                requestMap.nextIdType=&quot;custom&quot;
                                requestMap.customCounterCollection =&quot;counters&quot;
                                var id = MongoGlobalService(&quot;getMongoNextId&quot;, requestMap)

                                // var generatedUserName = userMap.get(&apos;firstname&apos;).length() &lt; 4 ? userMap.get(&apos;firstname&apos;) + &quot;_&quot; +  id.next_id : userMap.get(&apos;firstname&apos;).substring(0,4) + &quot;_&quot; +  id.next_id

                                //var generatedUserName = userMap.get(&apos;email&apos;).split(&apos;@&apos;)[0]
                                // userNameAndPassword.username = generatedUserName;
                                var generateRandomPassword = SHA512(userMap.get(&apos;email&apos;))
                                userNameAndPassword.password = generateRandomPassword.substring(0, 8)
                                logger.info(&quot;[Generate Random user Name Password] : Random Password and Name Generated is &quot;  +  JSON.stringify(userNameAndPassword))
                                } catch (e) {
                                logger.error(&quot;Exception occured while generating username and password&quot;+e)
                                }

                                return userNameAndPassword;
                                }

                                function SHA512(str){
                                logger.info(&quot;[SHA512] :  Going to generate SHA hash for data&quot; + str)
                                function int64(msint_32,lsint_32){this.highOrder=msint_32;this.lowOrder=lsint_32;}
                                var H=[new int64(0x6a09e667,0xf3bcc908),new int64(0xbb67ae85,0x84caa73b),new int64(0x3c6ef372,0xfe94f82b),new int64(0xa54ff53a,0x5f1d36f1),new int64(0x510e527f,0xade682d1),new int64(0x9b05688c,0x2b3e6c1f),new int64(0x1f83d9ab,0xfb41bd6b),new int64(0x5be0cd19,0x137e2179)];var K=[new int64(0x428a2f98,0xd728ae22),new int64(0x71374491,0x23ef65cd),new int64(0xb5c0fbcf,0xec4d3b2f),new int64(0xe9b5dba5,0x8189dbbc),new int64(0x3956c25b,0xf348b538),new int64(0x59f111f1,0xb605d019),new int64(0x923f82a4,0xaf194f9b),new int64(0xab1c5ed5,0xda6d8118),new int64(0xd807aa98,0xa3030242),new int64(0x12835b01,0x45706fbe),new int64(0x243185be,0x4ee4b28c),new int64(0x550c7dc3,0xd5ffb4e2),new int64(0x72be5d74,0xf27b896f),new int64(0x80deb1fe,0x3b1696b1),new int64(0x9bdc06a7,0x25c71235),new int64(0xc19bf174,0xcf692694),new int64(0xe49b69c1,0x9ef14ad2),new int64(0xefbe4786,0x384f25e3),new int64(0x0fc19dc6,0x8b8cd5b5),new int64(0x240ca1cc,0x77ac9c65),new int64(0x2de92c6f,0x592b0275),new int64(0x4a7484aa,0x6ea6e483),new int64(0x5cb0a9dc,0xbd41fbd4),new int64(0x76f988da,0x831153b5),new int64(0x983e5152,0xee66dfab),new int64(0xa831c66d,0x2db43210),new int64(0xb00327c8,0x98fb213f),new int64(0xbf597fc7,0xbeef0ee4),new int64(0xc6e00bf3,0x3da88fc2),new int64(0xd5a79147,0x930aa725),new int64(0x06ca6351,0xe003826f),new int64(0x14292967,0x0a0e6e70),new int64(0x27b70a85,0x46d22ffc),new int64(0x2e1b2138,0x5c26c926),new int64(0x4d2c6dfc,0x5ac42aed),new int64(0x53380d13,0x9d95b3df),new int64(0x650a7354,0x8baf63de),new int64(0x766a0abb,0x3c77b2a8),new int64(0x81c2c92e,0x47edaee6),new int64(0x92722c85,0x1482353b),new int64(0xa2bfe8a1,0x4cf10364),new int64(0xa81a664b,0xbc423001),new int64(0xc24b8b70,0xd0f89791),new int64(0xc76c51a3,0x0654be30),new int64(0xd192e819,0xd6ef5218),new int64(0xd6990624,0x5565a910),new int64(0xf40e3585,0x5771202a),new int64(0x106aa070,0x32bbd1b8),new int64(0x19a4c116,0xb8d2d0c8),new int64(0x1e376c08,0x5141ab53),new int64(0x2748774c,0xdf8eeb99),new int64(0x34b0bcb5,0xe19b48a8),new int64(0x391c0cb3,0xc5c95a63),new int64(0x4ed8aa4a,0xe3418acb),new int64(0x5b9cca4f,0x7763e373),new int64(0x682e6ff3,0xd6b2b8a3),new int64(0x748f82ee,0x5defb2fc),new int64(0x78a5636f,0x43172f60),new int64(0x84c87814,0xa1f0ab72),new int64(0x8cc70208,0x1a6439ec),new int64(0x90befffa,0x23631e28),new int64(0xa4506ceb,0xde82bde9),new int64(0xbef9a3f7,0xb2c67915),new int64(0xc67178f2,0xe372532b),new int64(0xca273ece,0xea26619c),new int64(0xd186b8c7,0x21c0c207),new int64(0xeada7dd6,0xcde0eb1e),new int64(0xf57d4f7f,0xee6ed178),new int64(0x06f067aa,0x72176fba),new int64(0x0a637dc5,0xa2c898a6),new int64(0x113f9804,0xbef90dae),new int64(0x1b710b35,0x131c471b),new int64(0x28db77f5,0x23047d84),new int64(0x32caab7b,0x40c72493),new int64(0x3c9ebe0a,0x15c9bebc),new int64(0x431d67c4,0x9c100d4c),new int64(0x4cc5d4be,0xcb3e42b6),new int64(0x597f299c,0xfc657e2a),new int64(0x5fcb6fab,0x3ad6faec),new int64(0x6c44198c,0x4a475817)];var W=new Array(64);var a,b,c,d,e,f,g,h,i,j;var T1,T2;var charsize=8;function utf8_encode(str){return unescape(encodeURIComponent(str));}
                                function str2binb(str){var bin=[];var mask=(1&lt;&lt;charsize)-1;var len=str.length*charsize;for(var i=0;i&lt;len;i+=charsize){bin[i&gt;&gt;5]|=(str.charCodeAt(i/charsize)&amp;mask)&lt;&lt;(32-charsize-(i % 32));}
                                return bin;}
                                function binb2hex(binarray){var hex_tab=&apos;0123456789abcdef&apos;;var str=&apos;&apos;;var length=binarray.length*4;var srcByte;for(var i=0;i&lt;length;i+=1){srcByte=binarray[i&gt;&gt;2]&gt;&gt;((3-(i % 4))*8);str+=hex_tab.charAt((srcByte&gt;&gt;4)&amp;0xF)+hex_tab.charAt(srcByte&amp;0xF);}
                                return str;}
                                function safe_add_2(x,y){var lsw,msw,lowOrder,highOrder;lsw=(x.lowOrder&amp;0xFFFF)+(y.lowOrder&amp;0xFFFF);msw=(x.lowOrder&gt;&gt;&gt;16)+(y.lowOrder&gt;&gt;&gt;16)+(lsw&gt;&gt;&gt;16);lowOrder=((msw&amp;0xFFFF)&lt;&lt;16)|(lsw&amp;0xFFFF);lsw=(x.highOrder&amp;0xFFFF)+(y.highOrder&amp;0xFFFF)+(msw&gt;&gt;&gt;16);msw=(x.highOrder&gt;&gt;&gt;16)+(y.highOrder&gt;&gt;&gt;16)+(lsw&gt;&gt;&gt;16);highOrder=((msw&amp;0xFFFF)&lt;&lt;16)|(lsw&amp;0xFFFF);return new int64(highOrder,lowOrder);}
                                function safe_add_4(a,b,c,d){var lsw,msw,lowOrder,highOrder;lsw=(a.lowOrder&amp;0xFFFF)+(b.lowOrder&amp;0xFFFF)+(c.lowOrder&amp;0xFFFF)+(d.lowOrder&amp;0xFFFF);msw=(a.lowOrder&gt;&gt;&gt;16)+(b.lowOrder&gt;&gt;&gt;16)+(c.lowOrder&gt;&gt;&gt;16)+(d.lowOrder&gt;&gt;&gt;16)+(lsw&gt;&gt;&gt;16);lowOrder=((msw&amp;0xFFFF)&lt;&lt;16)|(lsw&amp;0xFFFF);lsw=(a.highOrder&amp;0xFFFF)+(b.highOrder&amp;0xFFFF)+(c.highOrder&amp;0xFFFF)+(d.highOrder&amp;0xFFFF)+(msw&gt;&gt;&gt;16);msw=(a.highOrder&gt;&gt;&gt;16)+(b.highOrder&gt;&gt;&gt;16)+(c.highOrder&gt;&gt;&gt;16)+(d.highOrder&gt;&gt;&gt;16)+(lsw&gt;&gt;&gt;16);highOrder=((msw&amp;0xFFFF)&lt;&lt;16)|(lsw&amp;0xFFFF);return new int64(highOrder,lowOrder);}
                                function safe_add_5(a,b,c,d,e){var lsw,msw,lowOrder,highOrder;lsw=(a.lowOrder&amp;0xFFFF)+(b.lowOrder&amp;0xFFFF)+(c.lowOrder&amp;0xFFFF)+(d.lowOrder&amp;0xFFFF)+(e.lowOrder&amp;0xFFFF);msw=(a.lowOrder&gt;&gt;&gt;16)+(b.lowOrder&gt;&gt;&gt;16)+(c.lowOrder&gt;&gt;&gt;16)+(d.lowOrder&gt;&gt;&gt;16)+(e.lowOrder&gt;&gt;&gt;16)+(lsw&gt;&gt;&gt;16);lowOrder=((msw&amp;0xFFFF)&lt;&lt;16)|(lsw&amp;0xFFFF);lsw=(a.highOrder&amp;0xFFFF)+(b.highOrder&amp;0xFFFF)+(c.highOrder&amp;0xFFFF)+(d.highOrder&amp;0xFFFF)+(e.highOrder&amp;0xFFFF)+(msw&gt;&gt;&gt;16);msw=(a.highOrder&gt;&gt;&gt;16)+(b.highOrder&gt;&gt;&gt;16)+(c.highOrder&gt;&gt;&gt;16)+(d.highOrder&gt;&gt;&gt;16)+(e.highOrder&gt;&gt;&gt;16)+(lsw&gt;&gt;&gt;16);highOrder=((msw&amp;0xFFFF)&lt;&lt;16)|(lsw&amp;0xFFFF);return new int64(highOrder,lowOrder);}
                                function maj(x,y,z){return new int64((x.highOrder&amp;y.highOrder)^(x.highOrder&amp;z.highOrder)^(y.highOrder&amp;z.highOrder),(x.lowOrder&amp;y.lowOrder)^(x.lowOrder&amp;z.lowOrder)^(y.lowOrder&amp;z.lowOrder));}
                                function ch(x,y,z){return new int64((x.highOrder&amp;y.highOrder)^(~x.highOrder&amp;z.highOrder),(x.lowOrder&amp;y.lowOrder)^(~x.lowOrder&amp;z.lowOrder));}
                                function rotr(x,n){if(n&lt;=32){return new int64((x.highOrder&gt;&gt;&gt;n)|(x.lowOrder&lt;&lt;(32-n)),(x.lowOrder&gt;&gt;&gt;n)|(x.highOrder&lt;&lt;(32-n)));}else{return new int64((x.lowOrder&gt;&gt;&gt;n)|(x.highOrder&lt;&lt;(32-n)),(x.highOrder&gt;&gt;&gt;n)|(x.lowOrder&lt;&lt;(32-n)));}}
                                function sigma0(x){var rotr28=rotr(x,28);var rotr34=rotr(x,34);var rotr39=rotr(x,39);return new int64(rotr28.highOrder^rotr34.highOrder^rotr39.highOrder,rotr28.lowOrder^rotr34.lowOrder^rotr39.lowOrder);}
                                function sigma1(x){var rotr14=rotr(x,14);var rotr18=rotr(x,18);var rotr41=rotr(x,41);return new int64(rotr14.highOrder^rotr18.highOrder^rotr41.highOrder,rotr14.lowOrder^rotr18.lowOrder^rotr41.lowOrder);}
                                function gamma0(x){var rotr1=rotr(x,1),rotr8=rotr(x,8),shr7=shr(x,7);return new int64(rotr1.highOrder^rotr8.highOrder^shr7.highOrder,rotr1.lowOrder^rotr8.lowOrder^shr7.lowOrder);}
                                function gamma1(x){var rotr19=rotr(x,19);var rotr61=rotr(x,61);var shr6=shr(x,6);return new int64(rotr19.highOrder^rotr61.highOrder^shr6.highOrder,rotr19.lowOrder^rotr61.lowOrder^shr6.lowOrder);}
                                function shr(x,n){if(n&lt;=32){return new int64(x.highOrder&gt;&gt;&gt;n,x.lowOrder&gt;&gt;&gt;n|(x.highOrder&lt;&lt;(32-n)));}else{return new int64(0,x.highOrder&lt;&lt;(32-n));}}
                                str=utf8_encode(str);strlen=str.length*charsize;str=str2binb(str);str[strlen&gt;&gt;5]|=0x80&lt;&lt;(24-strlen % 32);str[(((strlen+128)&gt;&gt;10)&lt;&lt;5)+31]=strlen;for(var i=0;i&lt;str.length;i+=32){a=H[0];b=H[1];c=H[2];d=H[3];e=H[4];f=H[5];g=H[6];h=H[7];for(var j=0;j&lt;80;j++){if(j&lt;16){W[j]=new int64(str[j*2+i],str[j*2+i+1]);}else{W[j]=safe_add_4(gamma1(W[j-2]),W[j-7],gamma0(W[j-15]),W[j-16]);}
                                T1=safe_add_5(h,sigma1(e),ch(e,f,g),K[j],W[j]);T2=safe_add_2(sigma0(a),maj(a,b,c));h=g;g=f;f=e;e=safe_add_2(d,T1);d=c;c=b;b=a;a=safe_add_2(T1,T2);}
                                H[0]=safe_add_2(a,H[0]);H[1]=safe_add_2(b,H[1]);H[2]=safe_add_2(c,H[2]);H[3]=safe_add_2(d,H[3]);H[4]=safe_add_2(e,H[4]);H[5]=safe_add_2(f,H[5]);H[6]=safe_add_2(g,H[6]);H[7]=safe_add_2(h,H[7]);}
                                var binarray=[];for(var i=0;i&lt;H.length;i++){binarray.push(H[i].highOrder);binarray.push(H[i].lowOrder);}
                                return binb2hex(binarray);
                                }</code>
      </properties>
    </codeTemplate>
    <codeTemplate version="3.5.0">
      <id>0f13282b-f96d-487f-9bf6-d1318a027c7b</id>
      <name>getAuthToken</name>
      <revision>1</revision>
      <lastModified>
        <time>1597059085473</time>
        <timezone>America/New_York</timezone>
      </lastModified>
      <contextSet>
        <delegate>
          <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
          <contextType>DESTINATION_DISPATCHER</contextType>
          <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
          <contextType>SOURCE_RECEIVER</contextType>
          <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
        </delegate>
      </contextSet>
      <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
        <type>FUNCTION</type>
        <code>/**
                                Modify the description here. Modify the function name and parameters as needed. One function per
                                template is recommended; create a new code template for each new function.

                                @param {String} arg1 - arg1 description
                                @return {String} return description
                                */
                                function getAuthToken(username,password,url) {
                                // TODO: Enter code here
                                logger.info(&quot;[Get Auth Token] : Going to get Token via API &quot;)
                                try {
                var loginUrl =globalMap.get(&quot;minervaUrl&quot;) +  JSON.parse(configurationMap.get(&apos;apiInformation&apos;)).login_url
                                var json_data = {}
                                if(username &amp;&amp; password){
                                json_data.username = username
                                json_data.password = password
                                }else{
                                json_data.username=configurationMap.get(&apos;username&apos;)
                                json_data.password=configurationMap.get(&apos;password&apos;)
                                }

                                var attr= new java.util.HashMap()
                                if(url){

                                attr.put(&apos;url&apos;,url)
                                }else{
                                attr.put(&quot;url&quot;,loginUrl)

                                }

                                // attr.put(&quot;url&quot;,configurationMap.get(&apos;login_url&apos;))
                                var login_response = apiRequest(&apos;POST&apos;,json_data,attr)
                                logger.info(&quot;Auth login response x-auth-token generated ====== &quot;+ login_response);
                                var res = JSON.parse(login_response);
                                logger.info(&quot;Auth token Generated :&quot;+ res.token);
                                return res.token
                                }catch(e){
                                logger.error(&apos;Exception Occured while Getting api token&apos;+e)
                                }
                                }</code>
      </properties>
    </codeTemplate>
    <codeTemplate version="3.5.0">
      <id>3a859600-784b-49f9-94d0-6f90e4604755</id>
      <name>getCountryCodePrefix</name>
      <revision>1</revision>
      <lastModified>
        <time>1600848105809</time>
        <timezone>America/New_York</timezone>
      </lastModified>
      <contextSet>
        <delegate>
          <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
          <contextType>DESTINATION_DISPATCHER</contextType>
          <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
          <contextType>SOURCE_RECEIVER</contextType>
          <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
        </delegate>
      </contextSet>
      <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
        <type>FUNCTION</type>
        <code>/**
	Modify the description here. Modify the function name and parameters as needed. One function per
	template is recommended; create a new code template for each new function.

	@param {String} arg1 - arg1 description
	@return {String} return description
*/
function getCountryCodePrefix(countryCode) {
	 if(countryCode.startsWith(&quot;+&quot;) == false){
              countryCode  = &quot;+&quot; + countryCode
    }

    return countryCode
}</code>
      </properties>
    </codeTemplate>
    <codeTemplate version="3.5.0">
      <id>8d5f64c5-0f5b-402a-9ce7-2c6e49e29b9f</id>
      <name>MongoGlobalService</name>
      <revision>2</revision>
      <lastModified>
        <time>1599221496239</time>
        <timezone>America/New_York</timezone>
      </lastModified>
      <contextSet>
        <delegate>
            <contextType>CHANNEL_DEPLOY</contextType>
            <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
            <contextType>CHANNEL_UNDEPLOY</contextType>
            <contextType>CHANNEL_BATCH</contextType>
            <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
            <contextType>CHANNEL_PREPROCESSOR</contextType>
            <contextType>CHANNEL_POSTPROCESSOR</contextType>
            <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
            <contextType>SOURCE_RECEIVER</contextType>
            <contextType>CHANNEL_ATTACHMENT</contextType>
            <contextType>DESTINATION_DISPATCHER</contextType>
        </delegate>
      </contextSet>
      <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
        <type>FUNCTION</type>
        <code>/**
                                Modify the description here. Modify the function name and parameters as needed. One function per
                                template is recommended; create a new code template for each new function.

                                @param {Any} action - getMongoNextId, update, insert, delete, getMongoCon, search
                                @param {Any} requestMap - colletcionName and other parameters
                                @param {Any} mongoCon - mongoCon if exist otherwise null
                                @return {Map} return Return the Response in form of Map
                                */
                                function MongoGlobalService(action, requestMap, mongoCon) {
                                var result = {}; //It will return the response as the method call.

                                //Function to get the new/existing mongo connection
                                logger.info(&quot;Inside MongoGlobalService with action &quot;+action+&quot; ,requestMap=&quot;+JSON.stringify(requestMap)+&quot;  || &quot;+requestMap);
                                if(requestMap.find){
                                logger.info(&quot;FIND QUERY : &quot;+requestMap.find)
                                }
                                if((mongoCon == undefined) || (mongoCon == null) || (action &amp;&amp; action == &quot;getMongoCon&quot;))
                                {
                                mongoCon = globalMap.get(&apos;mongoClient&apos;);
                                if(!mongoCon || mongoCon == null || mongoCon == undefined || (action &amp;&amp; action == &quot;getMongoCon&quot;))
                                {
                                mongoCon = getMongoConnection();
                                }
                                if(action &amp;&amp; action == &quot;getMongoCon&quot;)
                                {
                                result.mongoCon = mongoCon;
                                }
                                }
                                //Action to get newSequenceNumber from counter collection or other collection if defined.
                                if(action &amp;&amp; action == &quot;getMongoNextId&quot;)
                                {
                                result.next_id = getMongoNextId(requestMap, mongoCon);
                                }

                                //Action to  insert data in collection
                                if(action &amp;&amp; action == &quot;insert&quot;)
                                {
                                result = insertData(requestMap, mongoCon);
                                }
                                //Action to update  data in collection
                                if(action &amp;&amp; action == &quot;update&quot;)
                                {
                                result = updateData(requestMap, mongoCon);
                                }
                                //Action to search/find data from database
                                if(action &amp;&amp; action == &quot;search&quot;)
                                {
                                result = searchData(requestMap, mongoCon);
                                }

                                //Action to search/find data from database
                                if(action &amp;&amp; action == &quot;delete&quot;)
                                {
                                result = deleteData(requestMap, mongoCon);
                                }
                                return result;
                                }

                                function getMongoNextId(requestMap, mongoCon)
                                {
                                var collectionName = requestMap.collectionName;
                                var finalCollection = &quot;&quot;;
                                var nextIdType = 	requestMap.nextIdType;  //It could be custom(using counter) or domain(using collection.next_id)
                                var customCounterCollection = &quot;counters&quot;  //Default use for customIdGenerator
                                var nextIdName = &quot;seq&quot;;
                                if(requestMap.customCounterCollection)
                                {
                                customCounterCollection = requestMap.customCounterCollection;
                                }
                                if(nextIdType == &quot;domain&quot;)
                                {
                                finalCollection = collectionName+&quot;.next_id&quot;;
                                nextIdName = &quot;next_id&quot;;
                                }
                                else
                                {
                                finalCollection = 	customCounterCollection;
                                }
                                var collection1 = mongoCon.getDB(configurationMap.get(&apos;mongoDBName&apos;)).getCollection(finalCollection);
                                var cursor1;
                                var result = &quot;&quot;;
                                var updateObj = new Packages.com.mongodb.BasicDBObject();
                                var find = new Packages.com.mongodb.BasicDBObject();
                                find.put(&quot;_id&quot;, collectionName);
                                updateObj.put(&quot;$inc&quot;, new Packages.com.mongodb.BasicDBObject(nextIdName,1));
                                cursor1 = collection1.findAndModify(find, null, null, false, updateObj, true, true);
                                result = cursor1.get(nextIdName);
                                return result+&quot;&quot;
                                }

                                function insertData(requestMap, mongoCon)  //Should contains requestMap.document as mongo document object Map
                                {
                                var collection1 = mongoCon.getDB(configurationMap.get(&apos;mongoDBName&apos;)).getCollection(requestMap.collectionName);
                                var cursor1;
                                var result = {};
                                cursor1 = collection1.insert(new Packages.com.mongodb.BasicDBObject(requestMap.document));
                                result.success = &quot;OK&quot;;
                                result.message = cursor1;
                                return result;
                                }

                                //Update data with requestMap.find, requestMap.document and requestMap.multi
                                function updateData(requestMap, mongoCon)  //Should contains requestMap.document as mongo document object Map
                                {
                                var collection1 = mongoCon.getDB(configurationMap.get(&apos;mongoDBName&apos;)).getCollection(requestMap.collectionName);
                                var cursor1;
                                var result = {};
                                var findObj = requestMap.find //It Should be mongo DB Object
                                var multi = (requestMap.multi) ? requestMap.multi : false //It should be boolean
                                var updateObj = new Packages.com.mongodb.BasicDBObject();
                                updateObj.put(&quot;$set&quot;, new Packages.com.mongodb.BasicDBObject(requestMap.document));
                                cursor1 = collection1.update(findObj, updateObj, false,multi);
                                result.success = &quot;OK&quot;;
                                result.message = cursor1;
                                return result;
                                }
                                //Search/find data with requestMap.find, requestMap.limit and  requestMap.sort
                                function searchData(requestMap, mongoCon)
                                {
                                logger.info(&quot;mongoCon in search Data &quot;+mongoCon);
                                var collection1 = mongoCon.getDB(configurationMap.get(&apos;mongoDBName&apos;)).getCollection(requestMap.collectionName);
                                logger.info(&quot;collection1 &quot;+collection1);
                                var cursor1;
                                var result = {};
                                var findObj = requestMap.find //It Should be mongo DB Object
                                var limit = (requestMap.limit) ? requestMap.limit : &quot;0&quot; //It should be String
                                var sort = (requestMap.sort) ? requestMap.sort : new Packages.com.mongodb.BasicDBObject();

                                cursor1 = collection1.find(findObj).sort(sort).limit(parseInt(limit));
                                logger.info(&quot;search Result &quot;+cursor1);
                                result.success = &quot;OK&quot;;
                                result.message = cursor1;
                                result.totalCount = cursor1.count();
                                return result;
                                }
                                //Delete data with requestMap.find
                                function deleteData(requestMap, mongoCon)
                                {
                                var collection1 = mongoCon.getDB(configurationMap.get(&apos;mongoDBName&apos;)).getCollection(requestMap.collectionName);
                                var cursor1;
                                var result = {};
                                var findObj = requestMap.find //It Should be mongo DB Object

                                cursor1 = collection1.remove(findObj);
                                result.success = &quot;OK&quot;;
                                result.message = cursor1;
                                return result;
                                }
                                function getMongoConnection()
                                {
                                var mongoIp = configurationMap.get(&apos;mongoIP&apos;)
                                var mongoPort = configurationMap.get(&apos;mongoPort&apos;)
                                var mongoDbName = configurationMap.get(&apos;mongoDBName&apos;)
                                var mongoUsername = configurationMap.get(&apos;mongoUsername&apos;)
                                var mongoPassword = configurationMap.get(&apos;mongoPassword&apos;)
                                var connectionsPerHost = parseInt(configurationMap.get(&apos;connectionsPerHost&apos;))
                                var mongoClient

                                if (!mongoClient || mongoClient == null) {
                                var options = Packages.com.mongodb.MongoClientOptions.builder()
                                .connectionsPerHost(connectionsPerHost)
                                .build();

                                var sa = new Packages.com.mongodb.ServerAddress(mongoIp, parseInt(mongoPort));

                                if (mongoUsername &amp;&amp; mongoPassword) {
                                var mongoCredentialList = new java.util.ArrayList();

                                mongoCredentialList.add(Packages.com.mongodb.MongoCredential.createCredential(mongoUsername, mongoDbName, mongoPassword.toCharArray()));

                                globalMap.put(&apos;mongoClient&apos;,new Packages.com.mongodb.MongoClient(sa, mongoCredentialList, options))

                                } else {
                                globalMap.put(&apos;mongoClient&apos;,new Packages.com.mongodb.MongoClient(sa, options))

                                }
                                } else {
                                globalMap.put(&apos;mongoClient&apos;,mongoClient);
                                }

                                mongoClient = globalMap.get(&apos;mongoClient&apos;)
                                return mongoClient
                                }</code>
      </properties>
    </codeTemplate>
    <codeTemplate version="3.5.0">
      <id>5b63c5bd-ec5e-4f2a-9076-0f67461d9987</id>
      <name>searchDataFromCollection</name>
      <revision>1</revision>
      <lastModified>
        <time>1597059085523</time>
        <timezone>America/New_York</timezone>
      </lastModified>
      <contextSet>
        <delegate>
          <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
          <contextType>DESTINATION_DISPATCHER</contextType>
          <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
          <contextType>SOURCE_RECEIVER</contextType>
          <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
        </delegate>
      </contextSet>
      <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
        <type>FUNCTION</type>
        <code>/**
                                Modify the description here. Modify the function name and parameters as needed. One function per
                                template is recommended; create a new code template for each new function.

                                @param {String} arg1 - arg1 description
                                @return {String} return description
                                */
                                function searchDataFromCollection(queryMap,collectionName) {
                                // TODO: Enter code here
                                logger.info(&quot;[User Group] : Inside Search Function &quot;+queryMap+&quot;============collectionName===&quot;+collectionName)
                                logger.info(&quot;Query Object is &quot;+queryMap)
                                var requestMap={};
                                requestMap.collectionName=collectionName;
                                requestMap.find=new Packages.com.mongodb.BasicDBObject(queryMap);
                                logger.info(&quot;Search Map Created : &quot;+ requestMap);
                                var searchResponse=MongoGlobalService(&quot;search&quot;,requestMap);
                                logger.info(&quot;====Search Map Cursor is :&quot;+ JSON.stringify(searchResponse));
                                logger.info(&quot;Count for this query is :&quot;+ searchResponse.totalCount)
                                logger.info(&quot;Search Map response  is : &quot;+ searchResponse.success);
                                return searchResponse;

                                }</code>
      </properties>
    </codeTemplate>
    <codeTemplate version="3.5.0">
      <id>0fdbf9cd-63ef-4695-9c12-63eabeff662f</id>
      <name>sendEmailNotification</name>
      <revision>1</revision>
      <lastModified>
        <time>1597059085739</time>
        <timezone>America/New_York</timezone>
      </lastModified>
      <contextSet>
        <delegate>
          <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
          <contextType>DESTINATION_DISPATCHER</contextType>
          <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
          <contextType>SOURCE_RECEIVER</contextType>
          <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
        </delegate>
      </contextSet>
      <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
        <type>FUNCTION</type>
        <code>/**
                                Modify the description here. Modify the function name and parameters as needed. One function per
                                template is recommended; create a new code template for each new function.

                                @param {String} arg1 - arg1 description
                                @return {String} return description
                                */
                                function sendEmailNotification(requestMap) {
                                // TODO: Enter code here
                                logger.info(&quot;[Send Email Notiification] :  Inside Send Email Notification Function&quot; )
                                try {
                var notificationSaveUrl =globalMap.get(&quot;minervaUrl&quot;)+ JSON.parse(configurationMap.get(&apos;apiInformation&apos;)).notificationCreateUrl
                var logoUrl = globalMap.get(&quot;minervaUrl&quot;) + JSON.parse(configurationMap.get(&apos;apiInformation&apos;)).logoUrl
                                //  var emailContent = JSON.parse(configurationMap.get(&apos;notificationInfo&apos;)).emailBody.replace(/USERNAME/g,requestMap.get(&apos;username&apos;)).replace(/PASSWORD/g,requestMap.get(&apos;password&apos;))
                                var keyVariables ={}
                                var messageVariable = {};
                                //    var subjectVariables = new java.util.HashMap();
                                messageVariable[&quot;&lt;userName&gt;&quot;]=requestMap.get(&apos;username&apos;);
                                messageVariable[&quot;&lt;password&gt;&quot;]=requestMap.get(&apos;password&apos;);
                                messageVariable[&quot;&lt;logoUrl&gt;&quot;]=logoUrl;

                                keyVariables[&apos;messageVariables&apos;] = messageVariable
                                //  keyVariables[&apos;subjectVariables&apos;] = subjectVariables;
                                logger.info(&quot;KeyVariables Json is &quot; +keyVariables +  &quot;Message Variables are &quot; +  messageVariable)

                                var notification_json_data = {
                                &quot;message&quot;:&quot;notificationMessage.meethActivity.notification.email.m62&quot;,
                                &quot;notificationType&quot;: &quot;email&quot;,
                                &quot;overrideUserPreference&quot;: false,
                                &quot;priority&quot;: &quot;INFO_MSG&quot;,
                                &quot;read&quot;: false,
                                &quot;recipientType&quot;: &quot;REGISTERED_USER&quot;,
                                &quot;sentDate&quot;: new java.util.Date(),
                                &quot;status&quot;: &quot;PENDING&quot;,
                                &quot;subject&quot;:&quot;notificationSubject.meethActivity.notification.email.s62&quot;,
                                // &quot;subject&quot;: JSON.parse(configurationMap.get(&apos;notificationInfo&apos;)).emailSubject,
                                &quot;toEmail&quot;:requestMap.get(&apos;userEmail&apos;),
                                &quot;keyVariables&quot;:keyVariables
                                }

                                logger.info(&quot;Notifictaion Create Json is &quot; + JSON.stringify(notification_json_data))
                                var attr = new java.util.HashMap()
                                attr.put(&quot;url&quot;,notificationSaveUrl)
                                attr.put(&quot;token&quot;,requestMap.get(&apos;token&apos;))
                                attr.put(&quot;apiInfo&quot;,configurationMap.get(&apos;apiInfo&apos;))
                                var notificationRes = apiRequest(&apos;POST&apos;,notification_json_data,attr)
                                return notificationRes
                                } catch (e) {
                                logger.error(&apos;Exception occured while sending email notification&apos;+e)
                                }

                                }</code>
      </properties>
    </codeTemplate>
    <codeTemplate version="3.5.0">
      <id>fdba9999-32c6-4b5f-87c3-e62ee8b78778</id>
      <name>trimListValue</name>
      <revision>3</revision>
      <lastModified>
          <time>1622200739546</time>
          <timezone>America/New_York</timezone>
      </lastModified>
      <contextSet>
          <delegate>
              <contextType>DESTINATION_DISPATCHER</contextType>
              <contextType>CHANNEL_DEPLOY</contextType>
              <contextType>CHANNEL_ATTACHMENT</contextType>
              <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
              <contextType>GLOBAL_UNDEPLOY</contextType>
              <contextType>SOURCE_RECEIVER</contextType>
              <contextType>CHANNEL_UNDEPLOY</contextType>
              <contextType>GLOBAL_PREPROCESSOR</contextType>
              <contextType>CHANNEL_POSTPROCESSOR</contextType>
              <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
              <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
              <contextType>CHANNEL_PREPROCESSOR</contextType>
              <contextType>CHANNEL_BATCH</contextType>
              <contextType>GLOBAL_DEPLOY</contextType>
              <contextType>GLOBAL_POSTPROCESSOR</contextType>
          </delegate>
      </contextSet>
      <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
          <type>FUNCTION</type>
          <code>
              function trimListValue(list) {
                logger.info(&quot;list.length : &quot;+list.length)
                for(var i=0; i&lt;list.length; i++){
                    list[i] = list[i].trim()
                }
                return list
              }
          </code>
      </properties>
    </codeTemplate>
    <codeTemplate version="3.5.0">
      <id>ae4e0a95-97b3-4b58-b946-e2a7e0e25f83</id>
      <name>updateFirstTimePassword</name>
      <revision>1</revision>
      <lastModified>
        <time>1597059085902</time>
        <timezone>America/New_York</timezone>
      </lastModified>
      <contextSet>
        <delegate>
          <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
          <contextType>DESTINATION_DISPATCHER</contextType>
          <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
          <contextType>SOURCE_RECEIVER</contextType>
          <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
        </delegate>
      </contextSet>
      <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
        <type>FUNCTION</type>
        <code>/**
                                Modify the description here. Modify the function name and parameters as needed. One function per
                                template is recommended; create a new code template for each new function.

                                @param {String} arg1 - arg1 description
                                @return {String} return description
                                */
                                function updateFirstTimePassword(username) {
                                // TODO: Enter code here
                                var queryMap = {}
                                var userSearchQuery=new Packages.com.mongodb.BasicDBObject(&apos;username&apos;,username)
                                queryMap.collectionName=JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).userCollectionName;
                                queryMap.find= userSearchQuery
                                if(username.indexOf(&apos;ldap1&apos;) &gt; 0){
                                queryMap.document = {
                                &quot;password&quot; : &quot;$2a$10$BvOQAAgtZvMSPCM/zdtgpOwWgDq.8dgmBMHid8hXSIH9Mtj/0rrpy&quot;,
                                &quot;passwordChangedTimeStamp&quot; :new Packages.java.util.Date(),
                                &quot;previousPasswords&quot; : [ ],
                                &quot;adminCreatedPasswordNeverChanged&quot; : false,
                                &quot;lastLoginTimeStamp&quot; : new Packages.java.util.Date()
                                }

                                }else {
                                queryMap.document = {
                                &quot;password&quot; : &quot;$2a$10$BvOQAAgtZvMSPCM/zdtgpOwWgDq.8dgmBMHid8hXSIH9Mtj/0rrpy&quot;
                                }
                                }

                                var passwordUpdate =  MongoGlobalService(&quot;update&quot;,queryMap)
                                if(passwordUpdate.success === &quot;OK&quot;){
                                logger.info(&quot;Password Updated Succesfully&quot;)
                                }

                                }</code>
      </properties>
    </codeTemplate>
  </codeTemplates>
</codeTemplateLibrary>